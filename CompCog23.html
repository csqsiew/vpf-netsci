<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Cynthia Siew" />


<title>CompCog 2023 Network Analysis Tutorial</title>

<script src="site_libs/header-attrs-2.18/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">An Introduction to Network Analysis for Psycholinguists</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="setup.html">Setup</a>
</li>
<li>
  <a href="part1-intro.html">Slides (VPF)</a>
</li>
<li>
  <a href="part2-demo.html">Workbook (VPF)</a>
</li>
<li>
  <a href="CompCog23.html">Workbook (CompCog)</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">CompCog 2023 Network Analysis Tutorial</h1>
<h3 class="subtitle">Modeling psychological data with cognitive
networks</h3>
<h4 class="author">Cynthia Siew</h4>
<h4 class="date">1st Feb 2023</h4>

</div>


<div id="set-up" class="section level1">
<h1>Set up</h1>
<pre class="r"><code>library(igraph)</code></pre>
<pre><code>## 
## Attaching package: &#39;igraph&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     decompose, spectrum</code></pre>
<pre><code>## The following object is masked from &#39;package:base&#39;:
## 
##     union</code></pre>
<pre class="r"><code>load(&#39;data/example-data-compcog.RData&#39;)</code></pre>
<p>There should be 3 objects loaded into your R workspace:</p>
<ul>
<li><code>pnet</code></li>
<li><code>snet</code></li>
<li><code>pnet_edgelist</code></li>
</ul>
<p><code>pnet</code> refers to a section of the phonological network
first described by Vitevitch (2008). The nodes represent English words,
and edges connect words that are phonological neighbors of each other
based on the 1-edit distance metric computed on their phonological
transcriptions (Luce &amp; Pisoni, 1998). E.g., /k@t/–/k@p/ are
neighboring nodes. Specifically, this network is the 2-hop network of
the word ‘speech’ - in addition to ‘speech’ itself, its immediate
phonological neighbors and the neighbors of its neighbors are included
in this representation.</p>
<p><code>pnet_edgelist</code> is the raw data that is used to create
<code>pnet</code>. It is an edgelist whereby each row depicts one edge
in the network.</p>
<p><code>snet</code> refers to a section of the word association network
using data from De Deyne et al. (2020). The nodes represent English
words, and edges connect words that are produced as free associations of
other words. E.g., “cat”–“dog” are neighboring nodes. This network has
edges with 2 interesting properties. (i) Each edge has a
<code>weight</code> attribute that corresponds to the associative
strength of two nodes, or the proportion of participants who provided a
specific response to the cue word. (ii) The edges are also
<code>directed</code> such the direction goes <em>from</em> the cue word
<em>to</em> the response word, i.e., “cat”-&gt;“dog”. Specifically, this
network is the 1-hop network of the word ‘cheese’ - in addition to
‘cheese’ itself, its immediate associates and the cue words that led to
the response ‘cheese’ are included in this representation. See <a
href="https://smallworldofwords.org/en/project/research"
class="uri">https://smallworldofwords.org/en/project/research</a> for
more information.</p>
<pre class="r"><code>summary(pnet) # undirected, unweighted edges </code></pre>
<pre><code>## IGRAPH ddad942 UN-- 39 121 -- 
## + attr: name (v/c)</code></pre>
<pre class="r"><code>summary(snet) # directed, weighted edges</code></pre>
<pre><code>## IGRAPH 9a00b73 DNW- 211 1324 -- 
## + attr: name (v/c), weight (e/n)</code></pre>
<p>Notice the two numbers on the first row: The first tells you the
number of nodes or vertices in the network, the second tells you the
number of edges or links.</p>
<p>There are also some cyptic looking characters. Let’s unpack that. The
first character is either “U” or “D” and tells you whether the edges are
“undirected” or “directed”. The second character “N” (if present) tells
you that the nodes have “names”. The third character “W” (if present)
tells you that the edges are weighted. The final character is blank
unless you have a special type of network known as a bipartite network
(in which case the fourth character is “B”).</p>
<p>On the second row, additional information about node or edge
attributes can be found if they have been specified in the construction
of the network. Both networks have node names, and the semantic network
has an edge attribute known as <code>weight</code>.</p>
<div id="loading-a-network-into-igraph" class="section level2">
<h2>Loading a network into <code>igraph</code></h2>
<p>There are a number of different ways to convert your raw data into a
network representation that <code>igraph</code> can analyze. This data
first needs to be organized as an edgelist or an adjacency matrix or an
adjacency list and then loaded into RStudio. Below I provide a quick
example of how an <strong>edgelist</strong> can be converted into a
network.</p>
<pre class="r"><code>head(pnet_edgelist) # preview first few rows of the edgelist </code></pre>
<pre><code>##      [,1]        [,2]       
## [1,] &quot;biC;beach&quot; &quot;iC;each&quot;  
## [2,] &quot;biC;beach&quot; &quot;liC;leach&quot;
## [3,] &quot;iC;each&quot;   &quot;liC;leach&quot;
## [4,] &quot;pi;p&quot;      &quot;pis;peace&quot;
## [5,] &quot;biC;beach&quot; &quot;piC;peach&quot;
## [6,] &quot;iC;each&quot;   &quot;piC;peach&quot;</code></pre>
<pre class="r"><code>pnet2 &lt;- graph_from_edgelist(pnet_edgelist,
                             directed = F) # the edges are undirected in this network 

summary(pnet2)</code></pre>
<pre><code>## IGRAPH 2e75c97 UN-- 39 121 -- 
## + attr: name (v/c)</code></pre>
<p>There are many useful functions in <code>igraph</code> (those that
begin with <code>graph_from_*</code>) for converting various kinds of
datasets into networks. The <code>igraph</code> manual is a good place
to start learning about these functions and their arguments to specify
edge or node attributes of the network. Outside of <code>igraph</code>
you will probably have to spend some time curating and wrangling your
data so that it is in the right formats for <code>igraph</code>.</p>
</div>
<div id="visualizations" class="section level2">
<h2>Visualizations</h2>
<p>Here are visualizations of the networks we will play around with
today.</p>
<pre class="r"><code>plot(pnet,
     vertex.frame.color = &#39;white&#39;,
     vertex.label.color = &#39;grey30&#39;,
     edge.color = &#39;black&#39;,
     vertex.label = gsub(&#39;[[:print:]]+;&#39;, &#39;&#39;, V(pnet)$name), # regex to only print the word names and not transcriptions
     layout = layout_with_lgl,
     frame = TRUE,
     margin = c(0,0,0,0),
     main = &#39;A partial phonological network of English words&#39;)</code></pre>
<p><img src="CompCog23_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<pre class="r"><code>plot(snet,
     vertex.frame.color = &#39;white&#39;,
     vertex.label.color = &#39;grey30&#39;,
     edge.color = &#39;black&#39;,
     vertex.color = &#39;seagreen&#39;,
     vertex.size = 5,
     edge.arrow.size = 0.4,
     layout = layout_with_graphopt,
     frame = TRUE,
     margin = c(0,0,0,0),
     main = &#39;A partial semantic network&#39;)</code></pre>
<p><img src="CompCog23_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div id="disclaimers" class="section level2">
<h2>Disclaimers</h2>
<p>Due to limited time, I assume that you have some familiarity with R
and RStudio. A gentle introduction to R programming can be found here:
<a href="https://psyr.djnavarro.net/"
class="uri">https://psyr.djnavarro.net/</a></p>
<p>I also choose to not cover in detail a number of important topics
such as how to convert your raw data into an <code>igraph</code> network
object, network visualization in <code>igraph</code> (for a great
introduction to this topic, see <a
href="https://kateto.net/network-visualization"
class="uri">https://kateto.net/network-visualization</a>), and other
methods of quantifying the community structure of the network (i.e.,
meso-level). Some of these topics are briefly touched on in a different
tutorial and you can find the materials here: <a
href="https://vpf-netsci.netlify.app/part2-demo.html"
class="uri">https://vpf-netsci.netlify.app/part2-demo.html</a></p>
</div>
</div>
<div id="measuring-the-network" class="section level1">
<h1>Measuring the network</h1>
<p>Once we have a network representation, the tools of network science
can be applied to analyze the networks in different ways. In this
tutorial we focus on a <em>descriptive</em> analysis of the network and
review various network measures that can be used to describe or quantify
network structure at three different levels of the network: the
micro-level (referring to the local structure and other properties of
individual nodes), the meso-level (subgroups or clusters of nodes), and
the macro-level (referring to the overall or global structure of the
network).</p>
<p><img
src="https://www.mdpi.com/education/education-10-00101/article_deploy/html/images/education-10-00101-g001.png" /></p>
<div id="micro-level-node-level" class="section level2">
<h2>Micro-level (node-level)</h2>
<p>Micro-level network measures provide you with information about
specific nodes in the network. These are generally known as centrality
measures in the network science literature. Centrality is the network
scientist’s way of quantifying the relative “importance” of a given node
relative to other nodes in the network. There are <a
href="http://schochastics.net/sna/periodic.html">many</a> different
definitions of what counts as “central”, as you will see in the
following subsections. There is no single “correct” or “best” metric -
which metrics are most useful to you will depend on the nature of the
system that you are modeling as well as the network behavior that you
interested in.</p>
<div id="degree-unweighted-edges" class="section level3">
<h3>Degree (unweighted edges)</h3>
<p>The <strong>degree</strong> of node <em>i</em> refers to the number
of edges or links connected to that node.</p>
<p>If your network has directed edges, <em>in-degree</em> refers to the
number of edges that are going towards the target node, whereas
<em>out-degree</em> refers to the number of edges that are going away
from the target node.</p>
<p><img
src="https://www.tlab.it/en/allegati/help_en_online/tlab_image/in_out_degree.jpg" /></p>
<pre class="r"><code># undirected network
degree(graph = pnet) # for all nodes in the network</code></pre>
<pre><code>##  xpik;apeak   biC;beach    sid;cede     iC;each   liC;leach        pi;p 
##           2           5           4           5           5           9 
##   p@C;patch   pis;peace   piC;peach    pik;peak    pil;peal   piz;pease 
##           6           9          22          12           9           9 
##    pit;peat    pin;peen    pip;peep   piv;peeve   pRC;perch   pIC;pitch 
##           9           9           9           9           6           6 
##   poC;poach   pWC;pouch priC;preach  pUC;putsch   riC;reach    sik;seek 
##           6           6           2           6           6           5 
##  slik;sleek  snik;sneak  sped;spade  spik;speak  spEk;speck   spEd;sped 
##           3           3           3          11           5           4 
## spiC;speech  spid;speed  spYk;spike  spok;spoke  spuk;spook   sp^d;spud 
##           3           8           4           4           4           3 
##  stid;steed  swid;swede   tiC;teach 
##           3           3           5</code></pre>
<pre class="r"><code>degree(graph = snet, v = &#39;cheese&#39;) # for a specific node in the network </code></pre>
<pre><code>## cheese 
##    231</code></pre>
<pre class="r"><code># directed network
degree(graph = snet, v = &#39;cheese&#39;, mode = &#39;in&#39;) # in-degree = incoming edges</code></pre>
<pre><code>## cheese 
##    185</code></pre>
<pre class="r"><code>degree(graph = snet, v = &#39;cheese&#39;, mode = &#39;out&#39;) # out-degree = outgoing edges </code></pre>
<pre><code>## cheese 
##     46</code></pre>
<pre class="r"><code>degree(graph = snet, v = &#39;cheese&#39;, mode = &#39;all&#39;) # in-degree + out-degree</code></pre>
<pre><code>## cheese 
##    231</code></pre>
</div>
<div id="strength-weighted-edges" class="section level3">
<h3>Strength (weighted edges)</h3>
<p>The <strong>strength</strong> of node <em>i</em> refers to the sum of
its adjacent edge <em>weights</em>. Only applicable to weighted
networks.</p>
<pre class="r"><code>strength(graph = snet) |&gt; head(5)</code></pre>
<pre><code>##      age     aged     ages    aging american 
##     0.57     0.55     0.04     0.17     0.36</code></pre>
<pre class="r"><code># for directed networks
strength(graph = snet, v = &#39;age&#39;, mode = &#39;in&#39;) # in-degree = incoming edges</code></pre>
<pre><code>##  age 
## 0.38</code></pre>
<pre class="r"><code>strength(graph = snet, v = &#39;age&#39;, mode = &#39;out&#39;) # out-degree = outgoing edges </code></pre>
<pre><code>##  age 
## 0.19</code></pre>
<pre class="r"><code>strength(graph = snet, v = &#39;age&#39;, mode = &#39;all&#39;) # in-degree + out-degree</code></pre>
<pre><code>##  age 
## 0.57</code></pre>
<p style="color:blue;">
<em>Relevant finding in psychology: De Deyne et al. (2019) found that
strength (operationalized as association frequency) was superior to, or
at least similar to, word frequency as a predictor of lexical decision
and semantic decision performance.</em>
</p>
</div>
<div id="local-clustering-coefficient-unweighted"
class="section level3">
<h3>Local Clustering Coefficient (unweighted)</h3>
<p>The <strong>local clustering coefficient</strong>, <em>C</em>, of
node <em>i</em> measures the ratio of the actual number of edges
existing among nodes directly connected to the target node <em>i</em> to
the number of all possible edges among these nodes.</p>
<p><em>C</em> ranges from 0 to 1. When <em>C</em> = 0, none of the
neighbors of a target node are neighbors of each other. When <em>C</em>
= 1, every neighbor is also a neighbor of all the other neighbors of a
target word.</p>
<p>You can think of the local clustering coefficient as providing a
measure of the level of interconnectivity among the local neighborhood
of the node.</p>
<p><img src="img/hcc-lcc.jpg" /></p>
<p><em>Both words have the same number of neighbors, but different local
clustering coefficients.</em></p>
<p style="color:blue;">
<em>Relevant finding in psychology: Chan &amp; Vitevitch (2009) showed
that words with higher clustering coefficients were responded to more
slowly than words with lower clustering coefficient in spoken word
recognition tasks (even after controling for the size of the
phonological neighborhood.</em>
</p>
<pre class="r"><code>transitivity(graph = pnet, type = &#39;local&#39;, vids = &#39;spik;speak&#39;) |&gt; round(3) # for a specific node in the network </code></pre>
<pre><code>## [1] 0.218</code></pre>
<pre class="r"><code># if you do not specify the vids argument then you get a value for all nodes in the network, ordered by V(pnet)$name </code></pre>
<p>A couple of things to note:</p>
<ol style="list-style-type: decimal">
<li><p>It is important to specify <code>type = local</code> for local
clustering coefficients, as compared to the global clustering
coefficient of the entire graph (this is a <a
href="#global-clustering-coefficient">macro-level measure</a> that we
will visit later)</p></li>
<li><p>Many of these functions contain additional arguments for
indicating whether to consider the directionality and weights of the
edges. If your graph is undirected and unweighted, these are ignored by
default. If your graph is directed and weighted, you can indicate
whether to include or exclude this information for the computation of
the network measure.</p></li>
</ol>
</div>
<div id="local-clustering-coefficient-weighted" class="section level3">
<h3>Local Clustering Coefficient (weighted)</h3>
<p>If you have a weighted network, you can compute local clustering
coefficients using Barrat et al.’s (2004) generalization of transitivity
to weighted networks by specifying <code>type = 'weighted'</code>. If
your network is unweighted, the generalization will return the
unweighted C (see example of ‘speak’ below).</p>
<pre class="r"><code># weighted network 
transitivity(graph = snet, type = &#39;local&#39;, vids = &#39;cheese&#39;) |&gt; round(3) </code></pre>
<pre><code>## [1] 0.043</code></pre>
<pre class="r"><code>transitivity(graph = snet, type = &#39;weighted&#39;, vids = &#39;cheese&#39;) |&gt; round(3) </code></pre>
<pre><code>## [1] 0.056</code></pre>
<pre class="r"><code># unweighted network 
transitivity(graph = pnet, type = &#39;local&#39;, vids = &#39;spik;speak&#39;) |&gt; round(3)</code></pre>
<pre><code>## [1] 0.218</code></pre>
<pre class="r"><code>transitivity(graph = pnet, type = &#39;weighted&#39;, vids = &#39;spik;speak&#39;) |&gt; round(3) # no difference with the previous</code></pre>
<pre><code>## [1] 0.218</code></pre>
</div>
<div id="closeness-centrality" class="section level3">
<h3>Closeness Centrality</h3>
<p>Closeness centrality of node <em>i</em> is the inverse of the average
of the length of the shortest path between node <em>i</em> and all other
nodes in the network. If a node has high closeness centrality, it means
that on average, it takes few steps to travel from that node to all
other nodes in the network. If a node has low closeness centrality, it
means that on average, it takes more steps to travel from that node to
all other nodes in the network.</p>
<p>Closeness centrality is commonly viewed as an indicator of the
<em>accessibility</em> of a node in the network from all other locations
in the network.</p>
<p><img
src="https://www.reliantsproject.com/wp-content/uploads/2020/06/reliants_keyconcepts-04.png" />
<em>This is a famous network (Krackhardt’s Kite) that nicely illustrates
the differences between degree, closeness, and betweenness
centrality.</em></p>
<pre class="r"><code># closeness centralities for directed networks, ignoring weights  
closeness(graph = snet, normalized = T, mode = &#39;all&#39;, weights = NA) |&gt; head() # both in- and out-</code></pre>
<pre><code>##       age      aged      ages     aging  american appetizer 
## 0.5060241 0.5072464 0.5023923 0.5060241 0.5134474 0.5121951</code></pre>
<pre class="r"><code>closeness(graph = snet, normalized = T, mode = &#39;in&#39;, weights = NA) |&gt; head() # only incoming edges considered </code></pre>
<pre><code>##       age      aged      ages     aging  american appetizer 
## 0.6666667 0.6666667       NaN 0.5000000 0.2790698 0.3279743</code></pre>
<pre class="r"><code>closeness(graph = snet, normalized = T, mode = &#39;out&#39;, weights = NA) |&gt; head() # only outgoing edges considered</code></pre>
<pre><code>##       age      aged      ages     aging  american appetizer 
## 0.3380282 0.3503650 0.3317422 0.3333333 0.3520408 0.3650794</code></pre>
<pre class="r"><code># weights are considered by default if graph has a weight attribute 
closeness(graph = snet, normalized = T, mode = &#39;all&#39;) |&gt; head()</code></pre>
<pre><code>##       age      aged      ages     aging  american appetizer 
##  18.46966  14.54294  18.60053  18.48592  19.84877  17.90281</code></pre>
<p>Note that closeness centrality can only be meaningfully computed for
connected graphs (so that a path exists between any pair of nodes). If
there are distinct network components, this means that for some sets of
node pairs, the path between them does not exist and closeness cannot be
computed. Usually, network scientists focus their analysis on the
largest connected component of the network and ignore the smaller
connected components (viewed as outliers).</p>
<p>It is typical to have <code>normalized = T</code> so that the values
are normalized with respect to the size of the network. As usual, you
can specify the <code>mode</code> and <code>weights</code> arguments
accordingly if you have directed/weighted networks to get the
corresponding versions of closeness centrality computed. However,
caution is needed as the interpretation of <code>weights</code> in this
context is to interpret them as <strong>distances</strong> rather than
<em>connection strengths</em>: higher weights = longer distances (From
<code>igraph</code> manual: “If the graph has a weight edge attribute,
then this is used by default. Weights are used for calculating weighted
shortest paths, so they are interpreted as distances.”). It is highly
recommended to read the manual carefully to understand the measures that
are being computed.</p>
<p style="color:blue;">
<em>Relevant finding in psychology: Siew (2018) showed that the
closeness centrality of words in an orthographic similarity network
influenced word naming and visual lexical decision performance
differently. Words of higher closeness centralities were responded to
more quickly in lexical decision, but were named more slowly.</em>
</p>
</div>
<div id="betweenness-centrality" class="section level3">
<h3>Betweenness Centrality</h3>
<p>Betweenness centrality is a measure of the degree to which nodes
stand in between each other. A node with a high betweenness centrality
is a node that is frequently found in the short paths of other pairs of
nodes in the network. In contrast, a node with a low betweenness
centrality is a node that is not usually found in the short paths of
node pairs. Betweeenness can be viewed as an indicator if whether a node
represents a “bottleneck” in the system.</p>
<pre class="r"><code># undirected, unweighted network 
betweenness(graph = pnet, normalized = T, weights = NA, directed = F) |&gt; head()</code></pre>
<pre><code>## xpik;apeak  biC;beach   sid;cede    iC;each  liC;leach       pi;p 
## 0.00000000 0.00000000 0.01730678 0.00000000 0.00000000 0.00000000</code></pre>
<pre class="r"><code># directed, weighted network 
betweenness(graph = snet, normalized = T, weights = NULL, directed = T) |&gt; head() # use weight and direction</code></pre>
<pre><code>##          age         aged         ages        aging     american    appetizer 
## 0.0002050581 0.0009881305 0.0000000000 0.0001367054 0.0103941672 0.0098454470</code></pre>
<p>The same considerations (about connected graphs, additional arguments
for weighted and directed graphs, normalization, interpretation of
weights as distances) from the closeness centrality section applies to
this section as well.</p>
</div>
<div id="page-rank-centrality" class="section level3">
<h3>Page Rank Centrality</h3>
<p>PageRank is a centrality measure developed by Google to rank webpages
(the historic paper describing the algorithm can be viewed <a
href="http://infolab.stanford.edu/~backrub/google.html">here</a>). The
general idea is that a random walker will traverse the network space and
their paths are biased by the link connectivity structure of the
network. The random walker restarts the walk after some time (simulating
“boredom” of the surfer). The number of visits received by a node
provides an indicator of its importance in the network. Intuitively, we
expect that nodes have a high PageRank if there are many nodes that
point to it, or if there are nodes that point to it that themselves have
a high PageRank.</p>
<pre class="r"><code># undirected, unweighted network 
page_rank(graph = pnet, directed = F, weights = NA)$vector |&gt; head()</code></pre>
<pre><code>## xpik;apeak  biC;beach   sid;cede    iC;each  liC;leach       pi;p 
## 0.01085805 0.02109911 0.02350068 0.02109911 0.02109911 0.02849254</code></pre>
<pre class="r"><code># directed, weighted network 
page_rank(graph = snet, directed = T, weights = NULL)$vector |&gt; head()</code></pre>
<pre><code>##          age         aged         ages        aging     american    appetizer 
## 0.0016034240 0.0012433152 0.0007545644 0.0009712994 0.0011928822 0.0008034249</code></pre>
<p>The <code>weights</code> and <code>directed</code> arguments can be
adjusted depending on your graph type. It is important to note that the
interpretation of edge weights here is that of “connection strength”
(from <code>igraph</code> manual: “This function interprets edge weights
as connection strengths. In the random surfer model, an edge with a
larger weight is more likely to be selected by the surfer.”). This is
different from the “distance” interpretation of edge weights by
closeness and betweenness.</p>
<p style="color:blue;">
<em>Relevant finding in psychology: Griffiths et al. (2007) showed that
Page Rank centralities of words in a word association network provided
good predictions for the words generated by participants in a letter
fluency task.</em>
</p>
</div>
</div>
<div id="meso-level-community-structure" class="section level2">
<h2>Meso-level (community structure)</h2>
<p>A common feature of many real-world networks is that they have
<strong>community structure</strong>. Nodes are considered to be part of
the same community if the density of connections among those nodes is
relatively higher than the density of connections between nodes from
different communities (Newman, 2006).</p>
<p><strong>Modularity, Q</strong>, is a measure of the density of links
inside communities in relation to the density of links between
communities (Fortunato, 2010). Networks with higher Q are said to show
strong evidence of community structure.</p>
<p><img src="img/karate-communities.png" /></p>
<p><em>Communities are depicted in different colors from another famous
network: Zachary’s Karate Club Network</em></p>
<p><strong>How do network scientists “find” communities in
networks?</strong></p>
<p>Many community detection methods have been developed by network
scientists to detect communities in networks. Each differs in their
implementation, and reflects the creator’s implicit definition of what
is a community. In this tutorial we go through only one of these methods
(Louvain) to demonstrate an example of community detection.</p>
<p>If you are interested to learn more about community detection, check
out Fortunato (2010) who provided a comprehensive comparison of various
community detection techniques.</p>
<div id="louvain-method-greedy-maximization-method"
class="section level3">
<h3>Louvain method (“greedy, maximization method”)</h3>
<p>The core idea behind this method is that communities are essentially
“mergers” of small communities (Blondel et al., 2008), reflecting the
self-similar nature of complex networks.</p>
<ol style="list-style-type: decimal">
<li>Each node is assigned to one community such that there are as many
communities as there are nodes. Then remove node <em>i</em> from its
community and placing it in the community of the neighbor which yields
the greatest gain in modularity.</li>
</ol>
<ul>
<li>repeat for all nodes in the network</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>A new network is built where nodes are the <em>communities found in
the previous phase</em>. Repeat Step 1.</li>
</ol>
<ul>
<li>repeat Step 1 and 2 until it is not possible to further increase the
value of Q</li>
</ul>
<pre class="r"><code>set.seed(8)

# run the community detection algorithm 
results_louvain &lt;- cluster_louvain(graph = pnet)

# overall results 
modularity(results_louvain)</code></pre>
<pre><code>## [1] 0.5795028</code></pre>
<pre class="r"><code>sizes(results_louvain)</code></pre>
<pre><code>## Community sizes
## 1 2 3 4 5 
## 9 7 8 9 6</code></pre>
<pre class="r"><code># specific community membership for each node 
cbind(
  results_louvain$names,
  results_louvain$membership
) </code></pre>
<pre><code>##       [,1]          [,2]
##  [1,] &quot;xpik;apeak&quot;  &quot;1&quot; 
##  [2,] &quot;biC;beach&quot;   &quot;2&quot; 
##  [3,] &quot;sid;cede&quot;    &quot;3&quot; 
##  [4,] &quot;iC;each&quot;     &quot;2&quot; 
##  [5,] &quot;liC;leach&quot;   &quot;2&quot; 
##  [6,] &quot;pi;p&quot;        &quot;4&quot; 
##  [7,] &quot;p@C;patch&quot;   &quot;5&quot; 
##  [8,] &quot;pis;peace&quot;   &quot;4&quot; 
##  [9,] &quot;piC;peach&quot;   &quot;2&quot; 
## [10,] &quot;pik;peak&quot;    &quot;4&quot; 
## [11,] &quot;pil;peal&quot;    &quot;4&quot; 
## [12,] &quot;piz;pease&quot;   &quot;4&quot; 
## [13,] &quot;pit;peat&quot;    &quot;4&quot; 
## [14,] &quot;pin;peen&quot;    &quot;4&quot; 
## [15,] &quot;pip;peep&quot;    &quot;4&quot; 
## [16,] &quot;piv;peeve&quot;   &quot;4&quot; 
## [17,] &quot;pRC;perch&quot;   &quot;5&quot; 
## [18,] &quot;pIC;pitch&quot;   &quot;5&quot; 
## [19,] &quot;poC;poach&quot;   &quot;5&quot; 
## [20,] &quot;pWC;pouch&quot;   &quot;5&quot; 
## [21,] &quot;priC;preach&quot; &quot;2&quot; 
## [22,] &quot;pUC;putsch&quot;  &quot;5&quot; 
## [23,] &quot;riC;reach&quot;   &quot;2&quot; 
## [24,] &quot;sik;seek&quot;    &quot;1&quot; 
## [25,] &quot;slik;sleek&quot;  &quot;1&quot; 
## [26,] &quot;snik;sneak&quot;  &quot;1&quot; 
## [27,] &quot;sped;spade&quot;  &quot;3&quot; 
## [28,] &quot;spik;speak&quot;  &quot;1&quot; 
## [29,] &quot;spEk;speck&quot;  &quot;1&quot; 
## [30,] &quot;spEd;sped&quot;   &quot;3&quot; 
## [31,] &quot;spiC;speech&quot; &quot;3&quot; 
## [32,] &quot;spid;speed&quot;  &quot;3&quot; 
## [33,] &quot;spYk;spike&quot;  &quot;1&quot; 
## [34,] &quot;spok;spoke&quot;  &quot;1&quot; 
## [35,] &quot;spuk;spook&quot;  &quot;1&quot; 
## [36,] &quot;sp^d;spud&quot;   &quot;3&quot; 
## [37,] &quot;stid;steed&quot;  &quot;3&quot; 
## [38,] &quot;swid;swede&quot;  &quot;3&quot; 
## [39,] &quot;tiC;teach&quot;   &quot;2&quot;</code></pre>
<p>Saving the community detection results as a <code>communities</code>
object enables the use of special functions like
<code>modularity()</code> and <code>sizes()</code> to obtain the
modularity of the network and its community sizes. I have also included
code that shows how to extract the community memberships of all nodes in
the network for further analysis. This applies to the other community
detection algorithms as well.</p>
<p style="color:blue;">
<em>Relevant finding in psychology: Siew (2013) found robust community
structure in the phonological network, and words in the same community
tended to share similar lexical and phonological properties.</em>
</p>
</div>
</div>
<div id="macro-level-network-level" class="section level2">
<h2>Macro-level (network-level)</h2>
<p>In this section, we will review network science measures that
describe the overall or global structure of the entire network. You can
think of these measures as providing a “bird’s eye view” of your
network, and they are useful for comparing different network
representations.</p>
<div id="average-shortest-path-length" class="section level3">
<h3>Average Shortest Path Length</h3>
<p><strong>Average shortest path length</strong> (ASPL) refers to the
mean of the shortest possible path between all possible pairs of nodes
in the network. (This loosely corresponds to the idea of “six degrees of
separation” in social networks.)</p>
<p><img
src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse2.mm.bing.net%2Fth%3Fid%3DOIP.7M5pmG4w5Nnp610i1j7rLQHaFv%26pid%3DApi&amp;f=1" /></p>
<p><em>Example depicting the shortest path between nodes 25 and
16.</em></p>
<pre class="r"><code># undirected, unweighted network 
average.path.length(graph = pnet) </code></pre>
<pre><code>## [1] 2.557355</code></pre>
<pre class="r"><code># an alternative function - both give the same result 
mean_distance(graph = pnet)</code></pre>
<pre><code>## [1] 2.557355</code></pre>
<pre class="r"><code># directed, weighted network 
mean_distance(graph = snet, weights = NULL, directed = T) # consider weights and direction</code></pre>
<pre><code>## [1] 0.1090017</code></pre>
<pre class="r"><code>mean_distance(graph = snet, weights = NULL, directed = F) # ignore direction </code></pre>
<pre><code>## [1] 0.06239856</code></pre>
<pre class="r"><code>mean_distance(graph = snet, weights = NA, directed = T) # ignore weights </code></pre>
<pre><code>## [1] 2.926504</code></pre>
<p style="color:blue;">
<em>Relevant finding in psychology: Siew (2018) showed that concept
networks (constructed from concept maps generated by students) with
larger average shortest path lengths were associated with higher quiz
scores, after controlling for network size.</em>
</p>
</div>
<div id="global-clustering-coefficient" class="section level3">
<h3>Global Clustering Coefficient</h3>
<p><strong>Global clustering coefficient</strong> refers to the number
of closed triangles in the network relative to the number of possible
triangles. It is a measure of overall level of <em>local</em>
connectivity among nodes in the network.</p>
<p>A simple way of thinking about this concept is that it is measuring
the probability that each pair of “friends” of a given node are also
friends with each other.</p>
<pre class="r"><code>transitivity(graph = pnet, type = &#39;global&#39;)</code></pre>
<pre><code>## [1] 0.6805869</code></pre>
<pre class="r"><code>transitivity(graph = snet, type = &#39;global&#39;)</code></pre>
<pre><code>## [1] 0.1588113</code></pre>
</div>
<div id="small-world-index" class="section level3">
<h3>Small World Index</h3>
<p>The term “small world” has a specific meaning in network science as
compared to the layperson’s. A network is considered to have small world
characteristics if (i) its ASPL is <em>shorter</em> than that of a
randomly generated network with the same number of nodes and edges, and
(ii) its global C is <em>larger</em> than that of a randomly generated
network with the same number of nodes and edges. There are various ways
to compute a value that quantifies the “small worldness” of a network,
although we do not cover them here (see Humphries and Gurney, 2008, for
an example, and Neal, 2017, for a comparison of different methods).</p>
<p>The main take home message is that a small world network has high
levels of local clustering (nodes whose neighbors are also neighbors of
each other), but there also exists a number of shortcuts that
drastically reduces the overall distances/path lengths between nodes.
See below for an illustration of this idea.</p>
<p><img src="img/small-world.gif" /></p>
</div>
<div id="network-density" class="section level3">
<h3>Network Density</h3>
<p><strong>Network density</strong> refers to the ratio of the number of
(existing) edges and the number of possible edges among nodes in the
network.</p>
<p><img src="img/density.png" /></p>
<p><em>Simple example of networks with lower and higher network
densities.</em></p>
<pre class="r"><code>graph.density(graph = pnet)</code></pre>
<pre><code>## [1] 0.1632928</code></pre>
<pre class="r"><code>graph.density(graph = snet)</code></pre>
<pre><code>## [1] 0.02988039</code></pre>
</div>
<div id="network-diameter" class="section level3">
<h3>Network Diameter</h3>
<p><strong>Network diameter</strong> refers to length of the longest
shortest path between nodes in the network. Instead of getting the mean
of all the shortest paths as you did in ASPL, what is the
<em>maximum</em> length of those short paths?</p>
<p><img src="img/diameter.png" /></p>
<p><em>Simple example of networks with higher and lower network
diameters</em></p>
<pre class="r"><code># undirected, unweighted graph 
diameter(graph = pnet)</code></pre>
<pre><code>## [1] 4</code></pre>
<pre class="r"><code># directed, weighted graph 
diameter(graph = snet, directed = T, weights = NULL) # consider weights and direction</code></pre>
<pre><code>## [1] 0.88</code></pre>
<pre class="r"><code>diameter(graph = snet, directed = F, weights = NULL) # ignore direction </code></pre>
<pre><code>## [1] 0.56</code></pre>
<pre class="r"><code>diameter(graph = snet, directed = T, weights = NA) # ignore weights </code></pre>
<pre><code>## [1] 7</code></pre>
</div>
</div>
</div>
<div id="additional-resources" class="section level1">
<h1>Additional Resources</h1>
<p>Ognyanova, K. (2021) Network visualization with R. Retrieved from
www.kateto.net/network-visualization. <a
href="https://kateto.net/network-visualization"
class="uri">https://kateto.net/network-visualization</a></p>
<p>The official <code>igraph</code> manual (v.1.3.4). <a
href="https://igraph.org/r/doc/"
class="uri">https://igraph.org/r/doc/</a></p>
<p>Gephi: A multi-platform, free to download GUI app for network
analysis and visualization. <a href="https://gephi.org/"
class="uri">https://gephi.org/</a></p>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<p>Barrat, A., Barthélemy, M., Pastor-Satorras, R., &amp; Vespignani, A.
(2004). The architecture of complex weighted networks. Proceedings of
the National Academy of Sciences, 101(11), 3747–3752. <a
href="https://doi.org/10.1073/pnas.0400087101"
class="uri">https://doi.org/10.1073/pnas.0400087101</a></p>
<p>Blondel, V. D., Guillaume, J. L., Lambiotte, R., &amp; Lefebvre, E.
(2008). Fast unfolding of communities in large networks. Journal of
Statistical Mechanics: Theory and Experiment, 2008(10), P10008.</p>
<p>Chan, K. Y., &amp; Vitevitch, M. S. (2009). The influence of the
phonological neighborhood clustering coefficient on spoken word
recognition. Journal of Experimental Psychology: Human Perception and
Performance, 35(6), 1934–1949. <a
href="https://doi.org/10.1037/a0016902"
class="uri">https://doi.org/10.1037/a0016902</a></p>
<p>De Deyne, S., Navarro, D. J., Perfors, A., Brysbaert, M., &amp;
Storms, G. (2019). The “Small World of Words” English word association
norms for over 12,000 cue words. Behavior Research Methods, 51,
987–1006.</p>
<p>Fortunato, S. (2010). Community detection in graphs. Physics Reports,
486(3-5), 75-174.</p>
<p>Humphries, M. D., &amp; Gurney, K. (2008). Network
‘small-world-ness’: A quantitative method for determining canonical
network equivalence. PloS One, 3(4).</p>
<p>Griffiths, T. L., Steyvers, M., &amp; Firl, A. (2007). Google and the
Mind: Predicting Fluency With PageRank. Psychological Science, 18(12),
1069–1076. <a href="https://doi.org/10.1111/j.1467-9280.2007.02027.x"
class="uri">https://doi.org/10.1111/j.1467-9280.2007.02027.x</a></p>
<p>Luce, P. A., &amp; Pisoni, D. B. (1998). Recognizing spoken words:
The Neighborhood Activation Model. Ear and Hearing, 19(1), 1–36.</p>
<p>Neal, Z. P. (2017). How small is it? Comparing indices of small
worldliness. Network Science, 5(1), 30–44. <a
href="https://doi.org/10.1017/nws.2017.5"
class="uri">https://doi.org/10.1017/nws.2017.5</a></p>
<p>Newman, M. E. (2006). Modularity and community structure in networks.
Proceedings of the National Academy of Sciences, 103(23), 8577-8582.</p>
<p>Siew, C. S. Q. (2013). Community structure in the phonological
network. Frontiers in Psychology, 4, 553.</p>
<p>Siew, C. S. Q. (2018). The orthographic similarity structure of
English words: Insights from network science. Applied Network Science,
3(1), 13.</p>
<p>Siew, C. S. Q. (2018). Using network science to analyze concept maps
of psychology undergraduates. Applied Cognitive Psychology.</p>
<p>Vitevitch, M. S. (2008). What can graph theory tell us about word
learning and lexical retrieval? Journal of Speech, Language, and Hearing
Research, 51(2), 408–422. <a
href="https://doi.org/10.1044/1092-4388(2008/030)"
class="uri">https://doi.org/10.1044/1092-4388(2008/030)</a></p>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiQ29tcENvZyAyMDIzIE5ldHdvcmsgQW5hbHlzaXMgVHV0b3JpYWwiCnN1YnRpdGxlOiAiTW9kZWxpbmcgcHN5Y2hvbG9naWNhbCBkYXRhIHdpdGggY29nbml0aXZlIG5ldHdvcmtzIgphdXRob3I6ICJDeW50aGlhIFNpZXciCmRhdGU6ICIxc3QgRmViIDIwMjMiCm91dHB1dDoKICBodG1sX2RvY3VtZW50OgogICAgdG9jOiBUUlVFCiAgICB0b2NfZmxvYXQ6IFRSVUUKICAgIGRmX3ByaW50OiBwYWdlZAogICAgY29kZV9kb3dubG9hZDogdHJ1ZQotLS0KIyBTZXQgdXAgCgpgYGB7ciBzZXQtdXB9CmxpYnJhcnkoaWdyYXBoKQoKbG9hZCgnZGF0YS9leGFtcGxlLWRhdGEtY29tcGNvZy5SRGF0YScpCmBgYAoKVGhlcmUgc2hvdWxkIGJlIDMgb2JqZWN0cyBsb2FkZWQgaW50byB5b3VyIFIgd29ya3NwYWNlOgoKLSBgcG5ldGAKLSBgc25ldGAgCi0gYHBuZXRfZWRnZWxpc3RgCgpgcG5ldGAgcmVmZXJzIHRvIGEgc2VjdGlvbiBvZiB0aGUgcGhvbm9sb2dpY2FsIG5ldHdvcmsgZmlyc3QgZGVzY3JpYmVkIGJ5IFZpdGV2aXRjaCAoMjAwOCkuIFRoZSBub2RlcyByZXByZXNlbnQgRW5nbGlzaCB3b3JkcywgYW5kIGVkZ2VzIGNvbm5lY3Qgd29yZHMgdGhhdCBhcmUgcGhvbm9sb2dpY2FsIG5laWdoYm9ycyBvZiBlYWNoIG90aGVyIGJhc2VkIG9uIHRoZSAxLWVkaXQgZGlzdGFuY2UgbWV0cmljIGNvbXB1dGVkIG9uIHRoZWlyIHBob25vbG9naWNhbCB0cmFuc2NyaXB0aW9ucyAoTHVjZSAmIFBpc29uaSwgMTk5OCkuIEUuZy4sIC9rXEB0Ly0tL2tcQHAvIGFyZSBuZWlnaGJvcmluZyBub2Rlcy4gU3BlY2lmaWNhbGx5LCB0aGlzIG5ldHdvcmsgaXMgdGhlIDItaG9wIG5ldHdvcmsgb2YgdGhlIHdvcmQgJ3NwZWVjaCcgLSBpbiBhZGRpdGlvbiB0byAnc3BlZWNoJyBpdHNlbGYsIGl0cyBpbW1lZGlhdGUgcGhvbm9sb2dpY2FsIG5laWdoYm9ycyBhbmQgdGhlIG5laWdoYm9ycyBvZiBpdHMgbmVpZ2hib3JzIGFyZSBpbmNsdWRlZCBpbiB0aGlzIHJlcHJlc2VudGF0aW9uLgoKYHBuZXRfZWRnZWxpc3RgIGlzIHRoZSByYXcgZGF0YSB0aGF0IGlzIHVzZWQgdG8gY3JlYXRlIGBwbmV0YC4gSXQgaXMgYW4gZWRnZWxpc3Qgd2hlcmVieSBlYWNoIHJvdyBkZXBpY3RzIG9uZSBlZGdlIGluIHRoZSBuZXR3b3JrLgoKYHNuZXRgIHJlZmVycyB0byBhIHNlY3Rpb24gb2YgdGhlIHdvcmQgYXNzb2NpYXRpb24gbmV0d29yayB1c2luZyBkYXRhIGZyb20gRGUgRGV5bmUgZXQgYWwuICgyMDIwKS4gVGhlIG5vZGVzIHJlcHJlc2VudCBFbmdsaXNoIHdvcmRzLCBhbmQgZWRnZXMgY29ubmVjdCB3b3JkcyB0aGF0IGFyZSBwcm9kdWNlZCBhcyBmcmVlIGFzc29jaWF0aW9ucyBvZiBvdGhlciB3b3Jkcy4gRS5nLiwgImNhdCItLSJkb2ciIGFyZSBuZWlnaGJvcmluZyBub2Rlcy4gVGhpcyBuZXR3b3JrIGhhcyBlZGdlcyB3aXRoIDIgaW50ZXJlc3RpbmcgcHJvcGVydGllcy4gKGkpIEVhY2ggZWRnZSBoYXMgYSBgd2VpZ2h0YCBhdHRyaWJ1dGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgYXNzb2NpYXRpdmUgc3RyZW5ndGggb2YgdHdvIG5vZGVzLCBvciB0aGUgcHJvcG9ydGlvbiBvZiBwYXJ0aWNpcGFudHMgd2hvIHByb3ZpZGVkIGEgc3BlY2lmaWMgcmVzcG9uc2UgdG8gdGhlIGN1ZSB3b3JkLiAoaWkpIFRoZSBlZGdlcyBhcmUgYWxzbyBgZGlyZWN0ZWRgIHN1Y2ggdGhlIGRpcmVjdGlvbiBnb2VzICpmcm9tKiB0aGUgY3VlIHdvcmQgKnRvKiB0aGUgcmVzcG9uc2Ugd29yZCwgaS5lLiwgImNhdCItPiJkb2ciLiBTcGVjaWZpY2FsbHksIHRoaXMgbmV0d29yayBpcyB0aGUgMS1ob3AgbmV0d29yayBvZiB0aGUgd29yZCAnY2hlZXNlJyAtIGluIGFkZGl0aW9uIHRvICdjaGVlc2UnIGl0c2VsZiwgaXRzIGltbWVkaWF0ZSBhc3NvY2lhdGVzIGFuZCB0aGUgY3VlIHdvcmRzIHRoYXQgbGVkIHRvIHRoZSByZXNwb25zZSAnY2hlZXNlJyBhcmUgaW5jbHVkZWQgaW4gdGhpcyByZXByZXNlbnRhdGlvbi4gU2VlIGh0dHBzOi8vc21hbGx3b3JsZG9md29yZHMub3JnL2VuL3Byb2plY3QvcmVzZWFyY2ggZm9yIG1vcmUgaW5mb3JtYXRpb24uIAoKYGBge3IgcHJldmlld30Kc3VtbWFyeShwbmV0KSAjIHVuZGlyZWN0ZWQsIHVud2VpZ2h0ZWQgZWRnZXMgCgpzdW1tYXJ5KHNuZXQpICMgZGlyZWN0ZWQsIHdlaWdodGVkIGVkZ2VzCmBgYAoKTm90aWNlIHRoZSB0d28gbnVtYmVycyBvbiB0aGUgZmlyc3Qgcm93OiBUaGUgZmlyc3QgdGVsbHMgeW91IHRoZSBudW1iZXIgb2Ygbm9kZXMgb3IgdmVydGljZXMgaW4gdGhlIG5ldHdvcmssIHRoZSBzZWNvbmQgdGVsbHMgeW91IHRoZSBudW1iZXIgb2YgZWRnZXMgb3IgbGlua3MuIAoKVGhlcmUgYXJlIGFsc28gc29tZSBjeXB0aWMgbG9va2luZyBjaGFyYWN0ZXJzLiBMZXQncyB1bnBhY2sgdGhhdC4gVGhlIGZpcnN0IGNoYXJhY3RlciBpcyBlaXRoZXIgIlUiIG9yICJEIiBhbmQgdGVsbHMgeW91IHdoZXRoZXIgdGhlIGVkZ2VzIGFyZSAidW5kaXJlY3RlZCIgb3IgImRpcmVjdGVkIi4gVGhlIHNlY29uZCBjaGFyYWN0ZXIgIk4iIChpZiBwcmVzZW50KSB0ZWxscyB5b3UgdGhhdCB0aGUgbm9kZXMgaGF2ZSAibmFtZXMiLiBUaGUgdGhpcmQgY2hhcmFjdGVyICJXIiAoaWYgcHJlc2VudCkgdGVsbHMgeW91IHRoYXQgdGhlIGVkZ2VzIGFyZSB3ZWlnaHRlZC4gVGhlIGZpbmFsIGNoYXJhY3RlciBpcyBibGFuayB1bmxlc3MgeW91IGhhdmUgYSBzcGVjaWFsIHR5cGUgb2YgbmV0d29yayBrbm93biBhcyBhIGJpcGFydGl0ZSBuZXR3b3JrIChpbiB3aGljaCBjYXNlIHRoZSBmb3VydGggY2hhcmFjdGVyIGlzICJCIikuIAoKT24gdGhlIHNlY29uZCByb3csIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgbm9kZSBvciBlZGdlIGF0dHJpYnV0ZXMgY2FuIGJlIGZvdW5kIGlmIHRoZXkgaGF2ZSBiZWVuIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0aW9uIG9mIHRoZSBuZXR3b3JrLiBCb3RoIG5ldHdvcmtzIGhhdmUgbm9kZSBuYW1lcywgYW5kIHRoZSBzZW1hbnRpYyBuZXR3b3JrIGhhcyBhbiBlZGdlIGF0dHJpYnV0ZSBrbm93biBhcyBgd2VpZ2h0YC4gICAKCiMjIExvYWRpbmcgYSBuZXR3b3JrIGludG8gYGlncmFwaGAKClRoZXJlIGFyZSBhIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB0byBjb252ZXJ0IHlvdXIgcmF3IGRhdGEgaW50byBhIG5ldHdvcmsgcmVwcmVzZW50YXRpb24gdGhhdCBgaWdyYXBoYCBjYW4gYW5hbHl6ZS4gVGhpcyBkYXRhIGZpcnN0IG5lZWRzIHRvIGJlIG9yZ2FuaXplZCBhcyBhbiBlZGdlbGlzdCBvciBhbiBhZGphY2VuY3kgbWF0cml4IG9yIGFuIGFkamFjZW5jeSBsaXN0IGFuZCB0aGVuIGxvYWRlZCBpbnRvIFJTdHVkaW8uIEJlbG93IEkgcHJvdmlkZSBhIHF1aWNrIGV4YW1wbGUgb2YgaG93IGFuICoqZWRnZWxpc3QqKiBjYW4gYmUgY29udmVydGVkIGludG8gYSBuZXR3b3JrLiAKCmBgYHtyfQpoZWFkKHBuZXRfZWRnZWxpc3QpICMgcHJldmlldyBmaXJzdCBmZXcgcm93cyBvZiB0aGUgZWRnZWxpc3QgCgpwbmV0MiA8LSBncmFwaF9mcm9tX2VkZ2VsaXN0KHBuZXRfZWRnZWxpc3QsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0ZWQgPSBGKSAjIHRoZSBlZGdlcyBhcmUgdW5kaXJlY3RlZCBpbiB0aGlzIG5ldHdvcmsgCgpzdW1tYXJ5KHBuZXQyKQpgYGAKClRoZXJlIGFyZSBtYW55IHVzZWZ1bCBmdW5jdGlvbnMgaW4gYGlncmFwaGAgKHRob3NlIHRoYXQgYmVnaW4gd2l0aCBgZ3JhcGhfZnJvbV8qYCkgZm9yIGNvbnZlcnRpbmcgdmFyaW91cyBraW5kcyBvZiBkYXRhc2V0cyBpbnRvIG5ldHdvcmtzLiBUaGUgYGlncmFwaGAgbWFudWFsIGlzIGEgZ29vZCBwbGFjZSB0byBzdGFydCBsZWFybmluZyBhYm91dCB0aGVzZSBmdW5jdGlvbnMgYW5kIHRoZWlyIGFyZ3VtZW50cyB0byBzcGVjaWZ5IGVkZ2Ugb3Igbm9kZSBhdHRyaWJ1dGVzIG9mIHRoZSBuZXR3b3JrLiBPdXRzaWRlIG9mIGBpZ3JhcGhgIHlvdSB3aWxsIHByb2JhYmx5IGhhdmUgdG8gc3BlbmQgc29tZSB0aW1lIGN1cmF0aW5nIGFuZCB3cmFuZ2xpbmcgeW91ciBkYXRhIHNvIHRoYXQgaXQgaXMgaW4gdGhlIHJpZ2h0IGZvcm1hdHMgZm9yIGBpZ3JhcGhgLiAKCiMjIFZpc3VhbGl6YXRpb25zIAoKSGVyZSBhcmUgdmlzdWFsaXphdGlvbnMgb2YgdGhlIG5ldHdvcmtzIHdlIHdpbGwgcGxheSBhcm91bmQgd2l0aCB0b2RheS4gCgpgYGB7cn0KcGxvdChwbmV0LAogICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ICd3aGl0ZScsCiAgICAgdmVydGV4LmxhYmVsLmNvbG9yID0gJ2dyZXkzMCcsCiAgICAgZWRnZS5jb2xvciA9ICdibGFjaycsCiAgICAgdmVydGV4LmxhYmVsID0gZ3N1YignW1s6cHJpbnQ6XV0rOycsICcnLCBWKHBuZXQpJG5hbWUpLCAjIHJlZ2V4IHRvIG9ubHkgcHJpbnQgdGhlIHdvcmQgbmFtZXMgYW5kIG5vdCB0cmFuc2NyaXB0aW9ucwogICAgIGxheW91dCA9IGxheW91dF93aXRoX2xnbCwKICAgICBmcmFtZSA9IFRSVUUsCiAgICAgbWFyZ2luID0gYygwLDAsMCwwKSwKICAgICBtYWluID0gJ0EgcGFydGlhbCBwaG9ub2xvZ2ljYWwgbmV0d29yayBvZiBFbmdsaXNoIHdvcmRzJykKYGBgCgpgYGB7cn0KcGxvdChzbmV0LAogICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ICd3aGl0ZScsCiAgICAgdmVydGV4LmxhYmVsLmNvbG9yID0gJ2dyZXkzMCcsCiAgICAgZWRnZS5jb2xvciA9ICdibGFjaycsCiAgICAgdmVydGV4LmNvbG9yID0gJ3NlYWdyZWVuJywKICAgICB2ZXJ0ZXguc2l6ZSA9IDUsCiAgICAgZWRnZS5hcnJvdy5zaXplID0gMC40LAogICAgIGxheW91dCA9IGxheW91dF93aXRoX2dyYXBob3B0LAogICAgIGZyYW1lID0gVFJVRSwKICAgICBtYXJnaW4gPSBjKDAsMCwwLDApLAogICAgIG1haW4gPSAnQSBwYXJ0aWFsIHNlbWFudGljIG5ldHdvcmsnKQpgYGAKCiMjIERpc2NsYWltZXJzCgpEdWUgdG8gbGltaXRlZCB0aW1lLCBJIGFzc3VtZSB0aGF0IHlvdSBoYXZlIHNvbWUgZmFtaWxpYXJpdHkgd2l0aCBSIGFuZCBSU3R1ZGlvLiBBIGdlbnRsZSBpbnRyb2R1Y3Rpb24gdG8gUiBwcm9ncmFtbWluZyBjYW4gYmUgZm91bmQgaGVyZTogaHR0cHM6Ly9wc3lyLmRqbmF2YXJyby5uZXQvCgpJIGFsc28gY2hvb3NlIHRvIG5vdCBjb3ZlciBpbiBkZXRhaWwgYSBudW1iZXIgb2YgaW1wb3J0YW50IHRvcGljcyBzdWNoIGFzIGhvdyB0byBjb252ZXJ0IHlvdXIgcmF3IGRhdGEgaW50byBhbiBgaWdyYXBoYCBuZXR3b3JrIG9iamVjdCwgbmV0d29yayB2aXN1YWxpemF0aW9uIGluIGBpZ3JhcGhgIChmb3IgYSBncmVhdCBpbnRyb2R1Y3Rpb24gdG8gdGhpcyB0b3BpYywgc2VlIGh0dHBzOi8va2F0ZXRvLm5ldC9uZXR3b3JrLXZpc3VhbGl6YXRpb24pLCBhbmQgb3RoZXIgbWV0aG9kcyBvZiBxdWFudGlmeWluZyB0aGUgY29tbXVuaXR5IHN0cnVjdHVyZSBvZiB0aGUgbmV0d29yayAoaS5lLiwgbWVzby1sZXZlbCkuIFNvbWUgb2YgdGhlc2UgdG9waWNzIGFyZSBicmllZmx5IHRvdWNoZWQgb24gaW4gYSBkaWZmZXJlbnQgdHV0b3JpYWwgYW5kIHlvdSBjYW4gZmluZCB0aGUgbWF0ZXJpYWxzIGhlcmU6IGh0dHBzOi8vdnBmLW5ldHNjaS5uZXRsaWZ5LmFwcC9wYXJ0Mi1kZW1vLmh0bWwgCgojIE1lYXN1cmluZyB0aGUgbmV0d29yayAKCk9uY2Ugd2UgaGF2ZSBhIG5ldHdvcmsgcmVwcmVzZW50YXRpb24sIHRoZSB0b29scyBvZiBuZXR3b3JrIHNjaWVuY2UgY2FuIGJlIGFwcGxpZWQgdG8gYW5hbHl6ZSB0aGUgbmV0d29ya3MgaW4gZGlmZmVyZW50IHdheXMuIEluIHRoaXMgdHV0b3JpYWwgd2UgZm9jdXMgb24gYSAqZGVzY3JpcHRpdmUqIGFuYWx5c2lzIG9mIHRoZSBuZXR3b3JrIGFuZCByZXZpZXcgdmFyaW91cyBuZXR3b3JrIG1lYXN1cmVzIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGVzY3JpYmUgb3IgcXVhbnRpZnkgbmV0d29yayBzdHJ1Y3R1cmUgYXQgdGhyZWUgZGlmZmVyZW50IGxldmVscyBvZiB0aGUgbmV0d29yazogdGhlIG1pY3JvLWxldmVsIChyZWZlcnJpbmcgdG8gdGhlIGxvY2FsIHN0cnVjdHVyZSBhbmQgb3RoZXIgcHJvcGVydGllcyBvZiBpbmRpdmlkdWFsIG5vZGVzKSwgdGhlIG1lc28tbGV2ZWwgKHN1Ymdyb3VwcyBvciBjbHVzdGVycyBvZiBub2RlcyksIGFuZCB0aGUgbWFjcm8tbGV2ZWwgKHJlZmVycmluZyB0byB0aGUgb3ZlcmFsbCBvciBnbG9iYWwgc3RydWN0dXJlIG9mIHRoZSBuZXR3b3JrKS4gCgohW10oaHR0cHM6Ly93d3cubWRwaS5jb20vZWR1Y2F0aW9uL2VkdWNhdGlvbi0xMC0wMDEwMS9hcnRpY2xlX2RlcGxveS9odG1sL2ltYWdlcy9lZHVjYXRpb24tMTAtMDAxMDEtZzAwMS5wbmcpCgojIyBNaWNyby1sZXZlbCAobm9kZS1sZXZlbCkKCk1pY3JvLWxldmVsIG5ldHdvcmsgbWVhc3VyZXMgcHJvdmlkZSB5b3Ugd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBzcGVjaWZpYyBub2RlcyBpbiB0aGUgbmV0d29yay4gVGhlc2UgYXJlIGdlbmVyYWxseSBrbm93biBhcyBjZW50cmFsaXR5IG1lYXN1cmVzIGluIHRoZSBuZXR3b3JrIHNjaWVuY2UgbGl0ZXJhdHVyZS4gQ2VudHJhbGl0eSBpcyB0aGUgbmV0d29yayBzY2llbnRpc3QncyB3YXkgb2YgcXVhbnRpZnlpbmcgdGhlIHJlbGF0aXZlICJpbXBvcnRhbmNlIiBvZiBhIGdpdmVuIG5vZGUgcmVsYXRpdmUgdG8gb3RoZXIgbm9kZXMgaW4gdGhlIG5ldHdvcmsuIFRoZXJlIGFyZSBbbWFueV0oaHR0cDovL3NjaG9jaGFzdGljcy5uZXQvc25hL3BlcmlvZGljLmh0bWwpIGRpZmZlcmVudCBkZWZpbml0aW9ucyBvZiB3aGF0IGNvdW50cyBhcyAiY2VudHJhbCIsIGFzIHlvdSB3aWxsIHNlZSBpbiB0aGUgZm9sbG93aW5nIHN1YnNlY3Rpb25zLiBUaGVyZSBpcyBubyBzaW5nbGUgImNvcnJlY3QiIG9yICJiZXN0IiBtZXRyaWMgLSB3aGljaCBtZXRyaWNzIGFyZSBtb3N0IHVzZWZ1bCB0byB5b3Ugd2lsbCBkZXBlbmQgb24gdGhlIG5hdHVyZSBvZiB0aGUgc3lzdGVtIHRoYXQgeW91IGFyZSBtb2RlbGluZyBhcyB3ZWxsIGFzIHRoZSBuZXR3b3JrIGJlaGF2aW9yIHRoYXQgeW91IGludGVyZXN0ZWQgaW4uIAoKIyMjIERlZ3JlZSAodW53ZWlnaHRlZCBlZGdlcykKClRoZSAqKmRlZ3JlZSoqIG9mIG5vZGUgKmkqIHJlZmVycyB0byB0aGUgbnVtYmVyIG9mIGVkZ2VzIG9yIGxpbmtzIGNvbm5lY3RlZCB0byB0aGF0IG5vZGUuCgpJZiB5b3VyIG5ldHdvcmsgaGFzIGRpcmVjdGVkIGVkZ2VzLCAqaW4tZGVncmVlKiByZWZlcnMgdG8gdGhlIG51bWJlciBvZiBlZGdlcyB0aGF0IGFyZSBnb2luZyB0b3dhcmRzIHRoZSB0YXJnZXQgbm9kZSwgd2hlcmVhcyAqb3V0LWRlZ3JlZSogcmVmZXJzIHRvIHRoZSBudW1iZXIgb2YgZWRnZXMgdGhhdCBhcmUgZ29pbmcgYXdheSBmcm9tIHRoZSB0YXJnZXQgbm9kZS4gCgohW10oaHR0cHM6Ly93d3cudGxhYi5pdC9lbi9hbGxlZ2F0aS9oZWxwX2VuX29ubGluZS90bGFiX2ltYWdlL2luX291dF9kZWdyZWUuanBnKQoKYGBge3J9CiMgdW5kaXJlY3RlZCBuZXR3b3JrCmRlZ3JlZShncmFwaCA9IHBuZXQpICMgZm9yIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yawoKZGVncmVlKGdyYXBoID0gc25ldCwgdiA9ICdjaGVlc2UnKSAjIGZvciBhIHNwZWNpZmljIG5vZGUgaW4gdGhlIG5ldHdvcmsgCgojIGRpcmVjdGVkIG5ldHdvcmsKZGVncmVlKGdyYXBoID0gc25ldCwgdiA9ICdjaGVlc2UnLCBtb2RlID0gJ2luJykgIyBpbi1kZWdyZWUgPSBpbmNvbWluZyBlZGdlcwpkZWdyZWUoZ3JhcGggPSBzbmV0LCB2ID0gJ2NoZWVzZScsIG1vZGUgPSAnb3V0JykgIyBvdXQtZGVncmVlID0gb3V0Z29pbmcgZWRnZXMgCmRlZ3JlZShncmFwaCA9IHNuZXQsIHYgPSAnY2hlZXNlJywgbW9kZSA9ICdhbGwnKSAjIGluLWRlZ3JlZSArIG91dC1kZWdyZWUKYGBgCgojIyMgU3RyZW5ndGggKHdlaWdodGVkIGVkZ2VzKQoKVGhlICoqc3RyZW5ndGgqKiBvZiBub2RlICppKiByZWZlcnMgdG8gdGhlIHN1bSBvZiBpdHMgYWRqYWNlbnQgZWRnZSAqd2VpZ2h0cyouIE9ubHkgYXBwbGljYWJsZSB0byB3ZWlnaHRlZCBuZXR3b3Jrcy4gCgpgYGB7cn0Kc3RyZW5ndGgoZ3JhcGggPSBzbmV0KSB8PiBoZWFkKDUpCgojIGZvciBkaXJlY3RlZCBuZXR3b3JrcwpzdHJlbmd0aChncmFwaCA9IHNuZXQsIHYgPSAnYWdlJywgbW9kZSA9ICdpbicpICMgaW4tZGVncmVlID0gaW5jb21pbmcgZWRnZXMKc3RyZW5ndGgoZ3JhcGggPSBzbmV0LCB2ID0gJ2FnZScsIG1vZGUgPSAnb3V0JykgIyBvdXQtZGVncmVlID0gb3V0Z29pbmcgZWRnZXMgCnN0cmVuZ3RoKGdyYXBoID0gc25ldCwgdiA9ICdhZ2UnLCBtb2RlID0gJ2FsbCcpICMgaW4tZGVncmVlICsgb3V0LWRlZ3JlZQpgYGAKCjxwIHN0eWxlPSJjb2xvcjpibHVlOyI+KlJlbGV2YW50IGZpbmRpbmcgaW4gcHN5Y2hvbG9neTogRGUgRGV5bmUgZXQgYWwuICgyMDE5KSBmb3VuZCB0aGF0IHN0cmVuZ3RoIChvcGVyYXRpb25hbGl6ZWQgYXMgYXNzb2NpYXRpb24gZnJlcXVlbmN5KSB3YXMgc3VwZXJpb3IgdG8sIG9yIGF0IGxlYXN0IHNpbWlsYXIgdG8sIHdvcmQgZnJlcXVlbmN5IGFzIGEgcHJlZGljdG9yIG9mIGxleGljYWwgZGVjaXNpb24gYW5kIHNlbWFudGljIGRlY2lzaW9uIHBlcmZvcm1hbmNlLio8L3A+CgojIyMgTG9jYWwgQ2x1c3RlcmluZyBDb2VmZmljaWVudCAodW53ZWlnaHRlZCkKClRoZSAqKmxvY2FsIGNsdXN0ZXJpbmcgY29lZmZpY2llbnQqKiwgKkMqLCBvZiBub2RlICppKiBtZWFzdXJlcyB0aGUgcmF0aW8gb2YgdGhlIGFjdHVhbCBudW1iZXIgb2YgZWRnZXMgZXhpc3RpbmcgYW1vbmcgbm9kZXMgZGlyZWN0bHkgY29ubmVjdGVkIHRvIHRoZSB0YXJnZXQgbm9kZSAqaSogdG8gdGhlIG51bWJlciBvZiBhbGwgcG9zc2libGUgZWRnZXMgYW1vbmcgdGhlc2Ugbm9kZXMuIAoKKkMqIHJhbmdlcyBmcm9tIDAgdG8gMS4gV2hlbiAqQyogPSAwLCBub25lIG9mIHRoZSBuZWlnaGJvcnMgb2YgYSB0YXJnZXQgbm9kZSBhcmUgbmVpZ2hib3JzIG9mIGVhY2ggb3RoZXIuIFdoZW4gKkMqID0gMSwgZXZlcnkgbmVpZ2hib3IgaXMgYWxzbyBhIG5laWdoYm9yIG9mIGFsbCB0aGUgb3RoZXIgbmVpZ2hib3JzIG9mIGEgdGFyZ2V0IHdvcmQuCgpZb3UgY2FuIHRoaW5rIG9mIHRoZSBsb2NhbCBjbHVzdGVyaW5nIGNvZWZmaWNpZW50IGFzIHByb3ZpZGluZyBhIG1lYXN1cmUgb2YgdGhlIGxldmVsIG9mIGludGVyY29ubmVjdGl2aXR5IGFtb25nIHRoZSBsb2NhbCBuZWlnaGJvcmhvb2Qgb2YgdGhlIG5vZGUuIAoKIVtdKGltZy9oY2MtbGNjLmpwZykKCipCb3RoIHdvcmRzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIG5laWdoYm9ycywgYnV0IGRpZmZlcmVudCBsb2NhbCBjbHVzdGVyaW5nIGNvZWZmaWNpZW50cy4qCgo8cCBzdHlsZT0iY29sb3I6Ymx1ZTsiPipSZWxldmFudCBmaW5kaW5nIGluIHBzeWNob2xvZ3k6IENoYW4gJiBWaXRldml0Y2ggKDIwMDkpIHNob3dlZCB0aGF0IHdvcmRzIHdpdGggaGlnaGVyIGNsdXN0ZXJpbmcgY29lZmZpY2llbnRzIHdlcmUgcmVzcG9uZGVkIHRvIG1vcmUgc2xvd2x5IHRoYW4gd29yZHMgd2l0aCBsb3dlciBjbHVzdGVyaW5nIGNvZWZmaWNpZW50IGluIHNwb2tlbiB3b3JkIHJlY29nbml0aW9uIHRhc2tzIChldmVuIGFmdGVyIGNvbnRyb2xpbmcgZm9yIHRoZSBzaXplIG9mIHRoZSBwaG9ub2xvZ2ljYWwgbmVpZ2hib3Job29kLio8L3A+CgpgYGB7cn0KdHJhbnNpdGl2aXR5KGdyYXBoID0gcG5ldCwgdHlwZSA9ICdsb2NhbCcsIHZpZHMgPSAnc3BpaztzcGVhaycpIHw+IHJvdW5kKDMpICMgZm9yIGEgc3BlY2lmaWMgbm9kZSBpbiB0aGUgbmV0d29yayAKCiMgaWYgeW91IGRvIG5vdCBzcGVjaWZ5IHRoZSB2aWRzIGFyZ3VtZW50IHRoZW4geW91IGdldCBhIHZhbHVlIGZvciBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmssIG9yZGVyZWQgYnkgVihwbmV0KSRuYW1lIApgYGAKCkEgY291cGxlIG9mIHRoaW5ncyB0byBub3RlOgoKMS4gSXQgaXMgaW1wb3J0YW50IHRvIHNwZWNpZnkgYHR5cGUgPSBsb2NhbGAgZm9yIGxvY2FsIGNsdXN0ZXJpbmcgY29lZmZpY2llbnRzLCBhcyBjb21wYXJlZCB0byB0aGUgZ2xvYmFsIGNsdXN0ZXJpbmcgY29lZmZpY2llbnQgb2YgdGhlIGVudGlyZSBncmFwaCAodGhpcyBpcyBhIFttYWNyby1sZXZlbCBtZWFzdXJlXSgjZ2xvYmFsLWNsdXN0ZXJpbmctY29lZmZpY2llbnQpIHRoYXQgd2Ugd2lsbCB2aXNpdCBsYXRlcikgCgoyLiBNYW55IG9mIHRoZXNlIGZ1bmN0aW9ucyBjb250YWluIGFkZGl0aW9uYWwgYXJndW1lbnRzIGZvciBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gY29uc2lkZXIgdGhlIGRpcmVjdGlvbmFsaXR5IGFuZCB3ZWlnaHRzIG9mIHRoZSBlZGdlcy4gSWYgeW91ciBncmFwaCBpcyB1bmRpcmVjdGVkIGFuZCB1bndlaWdodGVkLCB0aGVzZSBhcmUgaWdub3JlZCBieSBkZWZhdWx0LiBJZiB5b3VyIGdyYXBoIGlzIGRpcmVjdGVkIGFuZCB3ZWlnaHRlZCwgeW91IGNhbiBpbmRpY2F0ZSB3aGV0aGVyIHRvIGluY2x1ZGUgb3IgZXhjbHVkZSB0aGlzIGluZm9ybWF0aW9uIGZvciB0aGUgY29tcHV0YXRpb24gb2YgdGhlIG5ldHdvcmsgbWVhc3VyZS4KCiMjIyBMb2NhbCBDbHVzdGVyaW5nIENvZWZmaWNpZW50ICh3ZWlnaHRlZCkKCklmIHlvdSBoYXZlIGEgd2VpZ2h0ZWQgbmV0d29yaywgeW91IGNhbiBjb21wdXRlIGxvY2FsIGNsdXN0ZXJpbmcgY29lZmZpY2llbnRzIHVzaW5nIEJhcnJhdCBldCBhbC4ncyAoMjAwNCkgZ2VuZXJhbGl6YXRpb24gb2YgdHJhbnNpdGl2aXR5IHRvIHdlaWdodGVkIG5ldHdvcmtzIGJ5IHNwZWNpZnlpbmcgYHR5cGUgPSAnd2VpZ2h0ZWQnYC4gSWYgeW91ciBuZXR3b3JrIGlzIHVud2VpZ2h0ZWQsIHRoZSBnZW5lcmFsaXphdGlvbiB3aWxsIHJldHVybiB0aGUgdW53ZWlnaHRlZCBDIChzZWUgZXhhbXBsZSBvZiAnc3BlYWsnIGJlbG93KS4gCgpgYGB7cn0KIyB3ZWlnaHRlZCBuZXR3b3JrIAp0cmFuc2l0aXZpdHkoZ3JhcGggPSBzbmV0LCB0eXBlID0gJ2xvY2FsJywgdmlkcyA9ICdjaGVlc2UnKSB8PiByb3VuZCgzKSAKCnRyYW5zaXRpdml0eShncmFwaCA9IHNuZXQsIHR5cGUgPSAnd2VpZ2h0ZWQnLCB2aWRzID0gJ2NoZWVzZScpIHw+IHJvdW5kKDMpIAoKIyB1bndlaWdodGVkIG5ldHdvcmsgCnRyYW5zaXRpdml0eShncmFwaCA9IHBuZXQsIHR5cGUgPSAnbG9jYWwnLCB2aWRzID0gJ3NwaWs7c3BlYWsnKSB8PiByb3VuZCgzKQoKdHJhbnNpdGl2aXR5KGdyYXBoID0gcG5ldCwgdHlwZSA9ICd3ZWlnaHRlZCcsIHZpZHMgPSAnc3BpaztzcGVhaycpIHw+IHJvdW5kKDMpICMgbm8gZGlmZmVyZW5jZSB3aXRoIHRoZSBwcmV2aW91cwpgYGAKCiMjIyBDbG9zZW5lc3MgQ2VudHJhbGl0eSAKCkNsb3NlbmVzcyBjZW50cmFsaXR5IG9mIG5vZGUgKmkqIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBhdmVyYWdlIG9mIHRoZSBsZW5ndGggb2YgdGhlIHNob3J0ZXN0IHBhdGggYmV0d2VlbiBub2RlICppKiBhbmQgYWxsIG90aGVyIG5vZGVzIGluIHRoZSBuZXR3b3JrLiBJZiBhIG5vZGUgaGFzIGhpZ2ggY2xvc2VuZXNzIGNlbnRyYWxpdHksIGl0IG1lYW5zIHRoYXQgb24gYXZlcmFnZSwgaXQgdGFrZXMgZmV3IHN0ZXBzIHRvIHRyYXZlbCBmcm9tIHRoYXQgbm9kZSB0byBhbGwgb3RoZXIgbm9kZXMgaW4gdGhlIG5ldHdvcmsuIElmIGEgbm9kZSBoYXMgbG93IGNsb3NlbmVzcyBjZW50cmFsaXR5LCBpdCBtZWFucyB0aGF0IG9uIGF2ZXJhZ2UsIGl0IHRha2VzIG1vcmUgc3RlcHMgdG8gdHJhdmVsIGZyb20gdGhhdCBub2RlIHRvIGFsbCBvdGhlciBub2RlcyBpbiB0aGUgbmV0d29yay4KCkNsb3NlbmVzcyBjZW50cmFsaXR5IGlzIGNvbW1vbmx5IHZpZXdlZCBhcyBhbiBpbmRpY2F0b3Igb2YgdGhlICphY2Nlc3NpYmlsaXR5KiBvZiBhIG5vZGUgaW4gdGhlIG5ldHdvcmsgZnJvbSBhbGwgb3RoZXIgbG9jYXRpb25zIGluIHRoZSBuZXR3b3JrLiAKCiFbXShodHRwczovL3d3dy5yZWxpYW50c3Byb2plY3QuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDIwLzA2L3JlbGlhbnRzX2tleWNvbmNlcHRzLTA0LnBuZykKKlRoaXMgaXMgYSBmYW1vdXMgbmV0d29yayAoS3JhY2toYXJkdCdzIEtpdGUpIHRoYXQgbmljZWx5IGlsbHVzdHJhdGVzIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGRlZ3JlZSwgY2xvc2VuZXNzLCBhbmQgYmV0d2Vlbm5lc3MgY2VudHJhbGl0eS4qCgpgYGB7cn0KIyBjbG9zZW5lc3MgY2VudHJhbGl0aWVzIGZvciBkaXJlY3RlZCBuZXR3b3JrcywgaWdub3Jpbmcgd2VpZ2h0cyAgCmNsb3NlbmVzcyhncmFwaCA9IHNuZXQsIG5vcm1hbGl6ZWQgPSBULCBtb2RlID0gJ2FsbCcsIHdlaWdodHMgPSBOQSkgfD4gaGVhZCgpICMgYm90aCBpbi0gYW5kIG91dC0KY2xvc2VuZXNzKGdyYXBoID0gc25ldCwgbm9ybWFsaXplZCA9IFQsIG1vZGUgPSAnaW4nLCB3ZWlnaHRzID0gTkEpIHw+IGhlYWQoKSAjIG9ubHkgaW5jb21pbmcgZWRnZXMgY29uc2lkZXJlZCAKY2xvc2VuZXNzKGdyYXBoID0gc25ldCwgbm9ybWFsaXplZCA9IFQsIG1vZGUgPSAnb3V0Jywgd2VpZ2h0cyA9IE5BKSB8PiBoZWFkKCkgIyBvbmx5IG91dGdvaW5nIGVkZ2VzIGNvbnNpZGVyZWQKCiMgd2VpZ2h0cyBhcmUgY29uc2lkZXJlZCBieSBkZWZhdWx0IGlmIGdyYXBoIGhhcyBhIHdlaWdodCBhdHRyaWJ1dGUgCmNsb3NlbmVzcyhncmFwaCA9IHNuZXQsIG5vcm1hbGl6ZWQgPSBULCBtb2RlID0gJ2FsbCcpIHw+IGhlYWQoKQpgYGAKCk5vdGUgdGhhdCBjbG9zZW5lc3MgY2VudHJhbGl0eSBjYW4gb25seSBiZSBtZWFuaW5nZnVsbHkgY29tcHV0ZWQgZm9yIGNvbm5lY3RlZCBncmFwaHMgKHNvIHRoYXQgYSBwYXRoIGV4aXN0cyBiZXR3ZWVuIGFueSBwYWlyIG9mIG5vZGVzKS4gSWYgdGhlcmUgYXJlIGRpc3RpbmN0IG5ldHdvcmsgY29tcG9uZW50cywgdGhpcyBtZWFucyB0aGF0IGZvciBzb21lIHNldHMgb2Ygbm9kZSBwYWlycywgdGhlIHBhdGggYmV0d2VlbiB0aGVtIGRvZXMgbm90IGV4aXN0IGFuZCBjbG9zZW5lc3MgY2Fubm90IGJlIGNvbXB1dGVkLiBVc3VhbGx5LCBuZXR3b3JrIHNjaWVudGlzdHMgZm9jdXMgdGhlaXIgYW5hbHlzaXMgb24gdGhlIGxhcmdlc3QgY29ubmVjdGVkIGNvbXBvbmVudCBvZiB0aGUgbmV0d29yayBhbmQgaWdub3JlIHRoZSBzbWFsbGVyIGNvbm5lY3RlZCBjb21wb25lbnRzICh2aWV3ZWQgYXMgb3V0bGllcnMpLiAKCkl0IGlzIHR5cGljYWwgdG8gaGF2ZSBgbm9ybWFsaXplZCA9IFRgIHNvIHRoYXQgdGhlIHZhbHVlcyBhcmUgbm9ybWFsaXplZCB3aXRoIHJlc3BlY3QgdG8gdGhlIHNpemUgb2YgdGhlIG5ldHdvcmsuIEFzIHVzdWFsLCB5b3UgY2FuIHNwZWNpZnkgdGhlIGBtb2RlYCBhbmQgYHdlaWdodHNgIGFyZ3VtZW50cyBhY2NvcmRpbmdseSBpZiB5b3UgaGF2ZSBkaXJlY3RlZC93ZWlnaHRlZCBuZXR3b3JrcyB0byBnZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmVyc2lvbnMgb2YgY2xvc2VuZXNzIGNlbnRyYWxpdHkgY29tcHV0ZWQuIEhvd2V2ZXIsIGNhdXRpb24gaXMgbmVlZGVkIGFzIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBgd2VpZ2h0c2AgaW4gdGhpcyBjb250ZXh0IGlzIHRvIGludGVycHJldCB0aGVtIGFzICoqZGlzdGFuY2VzKiogcmF0aGVyIHRoYW4gKmNvbm5lY3Rpb24gc3RyZW5ndGhzKjogaGlnaGVyIHdlaWdodHMgPSBsb25nZXIgZGlzdGFuY2VzIChGcm9tIGBpZ3JhcGhgIG1hbnVhbDogIklmIHRoZSBncmFwaCBoYXMgYSB3ZWlnaHQgZWRnZSBhdHRyaWJ1dGUsIHRoZW4gdGhpcyBpcyB1c2VkIGJ5IGRlZmF1bHQuIFdlaWdodHMgYXJlIHVzZWQgZm9yIGNhbGN1bGF0aW5nIHdlaWdodGVkIHNob3J0ZXN0IHBhdGhzLCBzbyB0aGV5IGFyZSBpbnRlcnByZXRlZCBhcyBkaXN0YW5jZXMuIikuIEl0IGlzIGhpZ2hseSByZWNvbW1lbmRlZCB0byByZWFkIHRoZSBtYW51YWwgY2FyZWZ1bGx5IHRvIHVuZGVyc3RhbmQgdGhlIG1lYXN1cmVzIHRoYXQgYXJlIGJlaW5nIGNvbXB1dGVkLiAKCjxwIHN0eWxlPSJjb2xvcjpibHVlOyI+KlJlbGV2YW50IGZpbmRpbmcgaW4gcHN5Y2hvbG9neTogU2lldyAoMjAxOCkgc2hvd2VkIHRoYXQgdGhlIGNsb3NlbmVzcyBjZW50cmFsaXR5IG9mIHdvcmRzIGluIGFuIG9ydGhvZ3JhcGhpYyBzaW1pbGFyaXR5IG5ldHdvcmsgaW5mbHVlbmNlZCB3b3JkIG5hbWluZyBhbmQgdmlzdWFsIGxleGljYWwgZGVjaXNpb24gcGVyZm9ybWFuY2UgZGlmZmVyZW50bHkuIFdvcmRzIG9mIGhpZ2hlciBjbG9zZW5lc3MgY2VudHJhbGl0aWVzIHdlcmUgcmVzcG9uZGVkIHRvIG1vcmUgcXVpY2tseSBpbiBsZXhpY2FsIGRlY2lzaW9uLCBidXQgd2VyZSBuYW1lZCBtb3JlIHNsb3dseS4qPC9wPgoKIyMjIEJldHdlZW5uZXNzIENlbnRyYWxpdHkgCgpCZXR3ZWVubmVzcyBjZW50cmFsaXR5IGlzIGEgbWVhc3VyZSBvZiB0aGUgZGVncmVlIHRvIHdoaWNoIG5vZGVzIHN0YW5kIGluIGJldHdlZW4gZWFjaCBvdGhlci4gQSBub2RlIHdpdGggYSBoaWdoIGJldHdlZW5uZXNzIGNlbnRyYWxpdHkgaXMgYSBub2RlIHRoYXQgaXMgZnJlcXVlbnRseSBmb3VuZCBpbiB0aGUgc2hvcnQgcGF0aHMgb2Ygb3RoZXIgcGFpcnMgb2Ygbm9kZXMgaW4gdGhlIG5ldHdvcmsuIEluIGNvbnRyYXN0LCBhIG5vZGUgd2l0aCBhIGxvdyBiZXR3ZWVubmVzcyBjZW50cmFsaXR5IGlzIGEgbm9kZSB0aGF0IGlzIG5vdCB1c3VhbGx5IGZvdW5kIGluIHRoZSBzaG9ydCBwYXRocyBvZiBub2RlIHBhaXJzLiBCZXR3ZWVlbm5lc3MgY2FuIGJlIHZpZXdlZCBhcyBhbiBpbmRpY2F0b3IgaWYgd2hldGhlciBhIG5vZGUgcmVwcmVzZW50cyBhICJib3R0bGVuZWNrIiBpbiB0aGUgc3lzdGVtLiAKCmBgYHtyfQojIHVuZGlyZWN0ZWQsIHVud2VpZ2h0ZWQgbmV0d29yayAKYmV0d2Vlbm5lc3MoZ3JhcGggPSBwbmV0LCBub3JtYWxpemVkID0gVCwgd2VpZ2h0cyA9IE5BLCBkaXJlY3RlZCA9IEYpIHw+IGhlYWQoKQoKIyBkaXJlY3RlZCwgd2VpZ2h0ZWQgbmV0d29yayAKYmV0d2Vlbm5lc3MoZ3JhcGggPSBzbmV0LCBub3JtYWxpemVkID0gVCwgd2VpZ2h0cyA9IE5VTEwsIGRpcmVjdGVkID0gVCkgfD4gaGVhZCgpICMgdXNlIHdlaWdodCBhbmQgZGlyZWN0aW9uCmBgYAoKVGhlIHNhbWUgY29uc2lkZXJhdGlvbnMgKGFib3V0IGNvbm5lY3RlZCBncmFwaHMsIGFkZGl0aW9uYWwgYXJndW1lbnRzIGZvciB3ZWlnaHRlZCBhbmQgZGlyZWN0ZWQgZ3JhcGhzLCBub3JtYWxpemF0aW9uLCBpbnRlcnByZXRhdGlvbiBvZiB3ZWlnaHRzIGFzIGRpc3RhbmNlcykgZnJvbSB0aGUgY2xvc2VuZXNzIGNlbnRyYWxpdHkgc2VjdGlvbiBhcHBsaWVzIHRvIHRoaXMgc2VjdGlvbiBhcyB3ZWxsLiAKCiMjIyBQYWdlIFJhbmsgQ2VudHJhbGl0eQoKUGFnZVJhbmsgaXMgYSBjZW50cmFsaXR5IG1lYXN1cmUgZGV2ZWxvcGVkIGJ5IEdvb2dsZSB0byByYW5rIHdlYnBhZ2VzICh0aGUgaGlzdG9yaWMgcGFwZXIgZGVzY3JpYmluZyB0aGUgYWxnb3JpdGhtIGNhbiBiZSB2aWV3ZWQgW2hlcmVdKGh0dHA6Ly9pbmZvbGFiLnN0YW5mb3JkLmVkdS9+YmFja3J1Yi9nb29nbGUuaHRtbCkpLiBUaGUgZ2VuZXJhbCBpZGVhIGlzIHRoYXQgYSByYW5kb20gd2Fsa2VyIHdpbGwgdHJhdmVyc2UgdGhlIG5ldHdvcmsgc3BhY2UgYW5kIHRoZWlyIHBhdGhzIGFyZSBiaWFzZWQgYnkgdGhlIGxpbmsgY29ubmVjdGl2aXR5IHN0cnVjdHVyZSBvZiB0aGUgbmV0d29yay4gVGhlIHJhbmRvbSB3YWxrZXIgcmVzdGFydHMgdGhlIHdhbGsgYWZ0ZXIgc29tZSB0aW1lIChzaW11bGF0aW5nICJib3JlZG9tIiBvZiB0aGUgc3VyZmVyKS4gVGhlIG51bWJlciBvZiB2aXNpdHMgcmVjZWl2ZWQgYnkgYSBub2RlIHByb3ZpZGVzIGFuIGluZGljYXRvciBvZiBpdHMgaW1wb3J0YW5jZSBpbiB0aGUgbmV0d29yay4gSW50dWl0aXZlbHksIHdlIGV4cGVjdCB0aGF0IG5vZGVzIGhhdmUgYSBoaWdoIFBhZ2VSYW5rIGlmIHRoZXJlIGFyZSBtYW55IG5vZGVzIHRoYXQgcG9pbnQgdG8gaXQsIG9yIGlmIHRoZXJlIGFyZSBub2RlcyB0aGF0IHBvaW50IHRvIGl0IHRoYXQgdGhlbXNlbHZlcyBoYXZlIGEgaGlnaCBQYWdlUmFuay4gCgpgYGB7cn0KIyB1bmRpcmVjdGVkLCB1bndlaWdodGVkIG5ldHdvcmsgCnBhZ2VfcmFuayhncmFwaCA9IHBuZXQsIGRpcmVjdGVkID0gRiwgd2VpZ2h0cyA9IE5BKSR2ZWN0b3IgfD4gaGVhZCgpCgojIGRpcmVjdGVkLCB3ZWlnaHRlZCBuZXR3b3JrIApwYWdlX3JhbmsoZ3JhcGggPSBzbmV0LCBkaXJlY3RlZCA9IFQsIHdlaWdodHMgPSBOVUxMKSR2ZWN0b3IgfD4gaGVhZCgpCmBgYAoKVGhlIGB3ZWlnaHRzYCBhbmQgYGRpcmVjdGVkYCBhcmd1bWVudHMgY2FuIGJlIGFkanVzdGVkIGRlcGVuZGluZyBvbiB5b3VyIGdyYXBoIHR5cGUuIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgdGhlIGludGVycHJldGF0aW9uIG9mIGVkZ2Ugd2VpZ2h0cyBoZXJlIGlzIHRoYXQgb2YgImNvbm5lY3Rpb24gc3RyZW5ndGgiIChmcm9tIGBpZ3JhcGhgIG1hbnVhbDogIlRoaXMgZnVuY3Rpb24gaW50ZXJwcmV0cyBlZGdlIHdlaWdodHMgYXMgY29ubmVjdGlvbiBzdHJlbmd0aHMuIEluIHRoZSByYW5kb20gc3VyZmVyIG1vZGVsLCBhbiBlZGdlIHdpdGggYSBsYXJnZXIgd2VpZ2h0IGlzIG1vcmUgbGlrZWx5IHRvIGJlIHNlbGVjdGVkIGJ5IHRoZSBzdXJmZXIuIikuIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gdGhlICJkaXN0YW5jZSIgaW50ZXJwcmV0YXRpb24gb2YgZWRnZSB3ZWlnaHRzIGJ5IGNsb3NlbmVzcyBhbmQgYmV0d2Vlbm5lc3MuIAoKPHAgc3R5bGU9ImNvbG9yOmJsdWU7Ij4qUmVsZXZhbnQgZmluZGluZyBpbiBwc3ljaG9sb2d5OiBHcmlmZml0aHMgZXQgYWwuICgyMDA3KSBzaG93ZWQgdGhhdCBQYWdlIFJhbmsgY2VudHJhbGl0aWVzIG9mIHdvcmRzIGluIGEgd29yZCBhc3NvY2lhdGlvbiBuZXR3b3JrIHByb3ZpZGVkIGdvb2QgcHJlZGljdGlvbnMgZm9yIHRoZSB3b3JkcyBnZW5lcmF0ZWQgYnkgcGFydGljaXBhbnRzIGluIGEgbGV0dGVyIGZsdWVuY3kgdGFzay4qPC9wPgoKIyMgTWVzby1sZXZlbCAoY29tbXVuaXR5IHN0cnVjdHVyZSkKCkEgY29tbW9uIGZlYXR1cmUgb2YgbWFueSByZWFsLXdvcmxkIG5ldHdvcmtzIGlzIHRoYXQgdGhleSBoYXZlICoqY29tbXVuaXR5IHN0cnVjdHVyZSoqLiBOb2RlcyBhcmUgY29uc2lkZXJlZCB0byBiZSBwYXJ0IG9mIHRoZSBzYW1lIGNvbW11bml0eSBpZiB0aGUgZGVuc2l0eSBvZiBjb25uZWN0aW9ucyBhbW9uZyB0aG9zZSBub2RlcyBpcyByZWxhdGl2ZWx5IGhpZ2hlciB0aGFuIHRoZSBkZW5zaXR5IG9mIGNvbm5lY3Rpb25zIGJldHdlZW4gbm9kZXMgZnJvbSBkaWZmZXJlbnQgY29tbXVuaXRpZXMgKE5ld21hbiwgMjAwNikuCgoqKk1vZHVsYXJpdHksIFEqKiwgaXMgYSBtZWFzdXJlIG9mIHRoZSBkZW5zaXR5IG9mIGxpbmtzIGluc2lkZSBjb21tdW5pdGllcyBpbiByZWxhdGlvbiB0byB0aGUgZGVuc2l0eSBvZiBsaW5rcyBiZXR3ZWVuIGNvbW11bml0aWVzIChGb3J0dW5hdG8sIDIwMTApLiBOZXR3b3JrcyB3aXRoIGhpZ2hlciBRIGFyZSBzYWlkIHRvIHNob3cgc3Ryb25nIGV2aWRlbmNlIG9mIGNvbW11bml0eSBzdHJ1Y3R1cmUuIAoKIVtdKGltZy9rYXJhdGUtY29tbXVuaXRpZXMucG5nKQoKKkNvbW11bml0aWVzIGFyZSBkZXBpY3RlZCBpbiBkaWZmZXJlbnQgY29sb3JzIGZyb20gYW5vdGhlciBmYW1vdXMgbmV0d29yazogWmFjaGFyeSdzIEthcmF0ZSBDbHViIE5ldHdvcmsqCgoqKkhvdyBkbyBuZXR3b3JrIHNjaWVudGlzdHMgImZpbmQiIGNvbW11bml0aWVzIGluIG5ldHdvcmtzPyoqIAoKTWFueSBjb21tdW5pdHkgZGV0ZWN0aW9uIG1ldGhvZHMgaGF2ZSBiZWVuIGRldmVsb3BlZCBieSBuZXR3b3JrIHNjaWVudGlzdHMgdG8gZGV0ZWN0IGNvbW11bml0aWVzIGluIG5ldHdvcmtzLiBFYWNoIGRpZmZlcnMgaW4gdGhlaXIgaW1wbGVtZW50YXRpb24sIGFuZCByZWZsZWN0cyB0aGUgY3JlYXRvcidzIGltcGxpY2l0IGRlZmluaXRpb24gb2Ygd2hhdCBpcyBhIGNvbW11bml0eS4gSW4gdGhpcyB0dXRvcmlhbCB3ZSBnbyB0aHJvdWdoIG9ubHkgb25lIG9mIHRoZXNlIG1ldGhvZHMgKExvdXZhaW4pIHRvIGRlbW9uc3RyYXRlIGFuIGV4YW1wbGUgb2YgY29tbXVuaXR5IGRldGVjdGlvbi4KCklmIHlvdSBhcmUgaW50ZXJlc3RlZCB0byBsZWFybiBtb3JlIGFib3V0IGNvbW11bml0eSBkZXRlY3Rpb24sIGNoZWNrIG91dCBGb3J0dW5hdG8gKDIwMTApIHdobyBwcm92aWRlZCBhIGNvbXByZWhlbnNpdmUgY29tcGFyaXNvbiBvZiB2YXJpb3VzIGNvbW11bml0eSBkZXRlY3Rpb24gdGVjaG5pcXVlcy4gCgojIyMgTG91dmFpbiBtZXRob2QgKCJncmVlZHksIG1heGltaXphdGlvbiBtZXRob2QiKQoKVGhlIGNvcmUgaWRlYSBiZWhpbmQgdGhpcyBtZXRob2QgaXMgdGhhdCBjb21tdW5pdGllcyBhcmUgZXNzZW50aWFsbHkg4oCcbWVyZ2Vyc+KAnSBvZiBzbWFsbCBjb21tdW5pdGllcyAoQmxvbmRlbCBldCBhbC4sIDIwMDgpLCByZWZsZWN0aW5nIHRoZSBzZWxmLXNpbWlsYXIgbmF0dXJlIG9mIGNvbXBsZXggbmV0d29ya3MuCgoxLiBFYWNoIG5vZGUgaXMgYXNzaWduZWQgdG8gb25lIGNvbW11bml0eSBzdWNoIHRoYXQgdGhlcmUgYXJlIGFzIG1hbnkgY29tbXVuaXRpZXMgYXMgdGhlcmUgYXJlIG5vZGVzLiBUaGVuIHJlbW92ZSBub2RlICppKiBmcm9tIGl0cyBjb21tdW5pdHkgYW5kIHBsYWNpbmcgaXQgaW4gdGhlIGNvbW11bml0eSBvZiB0aGUgbmVpZ2hib3Igd2hpY2ggeWllbGRzIHRoZSBncmVhdGVzdCBnYWluIGluIG1vZHVsYXJpdHkuIAogIC0gcmVwZWF0IGZvciBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmsKCjIuIEEgbmV3IG5ldHdvcmsgaXMgYnVpbHQgd2hlcmUgbm9kZXMgYXJlIHRoZSAqY29tbXVuaXRpZXMgZm91bmQgaW4gdGhlIHByZXZpb3VzIHBoYXNlKi4gUmVwZWF0IFN0ZXAgMS4gCiAgLSByZXBlYXQgU3RlcCAxIGFuZCAyIHVudGlsIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBmdXJ0aGVyIGluY3JlYXNlIHRoZSB2YWx1ZSBvZiBRCgpgYGB7cn0Kc2V0LnNlZWQoOCkKCiMgcnVuIHRoZSBjb21tdW5pdHkgZGV0ZWN0aW9uIGFsZ29yaXRobSAKcmVzdWx0c19sb3V2YWluIDwtIGNsdXN0ZXJfbG91dmFpbihncmFwaCA9IHBuZXQpCgojIG92ZXJhbGwgcmVzdWx0cyAKbW9kdWxhcml0eShyZXN1bHRzX2xvdXZhaW4pCnNpemVzKHJlc3VsdHNfbG91dmFpbikKCiMgc3BlY2lmaWMgY29tbXVuaXR5IG1lbWJlcnNoaXAgZm9yIGVhY2ggbm9kZSAKY2JpbmQoCiAgcmVzdWx0c19sb3V2YWluJG5hbWVzLAogIHJlc3VsdHNfbG91dmFpbiRtZW1iZXJzaGlwCikgCmBgYAoKU2F2aW5nIHRoZSBjb21tdW5pdHkgZGV0ZWN0aW9uIHJlc3VsdHMgYXMgYSBgY29tbXVuaXRpZXNgIG9iamVjdCBlbmFibGVzIHRoZSB1c2Ugb2Ygc3BlY2lhbCBmdW5jdGlvbnMgbGlrZSBgbW9kdWxhcml0eSgpYCBhbmQgYHNpemVzKClgIHRvIG9idGFpbiB0aGUgbW9kdWxhcml0eSBvZiB0aGUgbmV0d29yayBhbmQgaXRzIGNvbW11bml0eSBzaXplcy4gSSBoYXZlIGFsc28gaW5jbHVkZWQgY29kZSB0aGF0IHNob3dzIGhvdyB0byBleHRyYWN0IHRoZSBjb21tdW5pdHkgbWVtYmVyc2hpcHMgb2YgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIGZvciBmdXJ0aGVyIGFuYWx5c2lzLiBUaGlzIGFwcGxpZXMgdG8gdGhlIG90aGVyIGNvbW11bml0eSBkZXRlY3Rpb24gYWxnb3JpdGhtcyBhcyB3ZWxsLiAKCjxwIHN0eWxlPSJjb2xvcjpibHVlOyI+KlJlbGV2YW50IGZpbmRpbmcgaW4gcHN5Y2hvbG9neTogU2lldyAoMjAxMykgZm91bmQgcm9idXN0IGNvbW11bml0eSBzdHJ1Y3R1cmUgaW4gdGhlIHBob25vbG9naWNhbCBuZXR3b3JrLCBhbmQgd29yZHMgaW4gdGhlIHNhbWUgY29tbXVuaXR5IHRlbmRlZCB0byBzaGFyZSBzaW1pbGFyIGxleGljYWwgYW5kIHBob25vbG9naWNhbCBwcm9wZXJ0aWVzLio8L3A+CgojIyBNYWNyby1sZXZlbCAobmV0d29yay1sZXZlbCkKCkluIHRoaXMgc2VjdGlvbiwgd2Ugd2lsbCByZXZpZXcgbmV0d29yayBzY2llbmNlIG1lYXN1cmVzIHRoYXQgZGVzY3JpYmUgdGhlIG92ZXJhbGwgb3IgZ2xvYmFsIHN0cnVjdHVyZSBvZiB0aGUgZW50aXJlIG5ldHdvcmsuIFlvdSBjYW4gdGhpbmsgb2YgdGhlc2UgbWVhc3VyZXMgYXMgcHJvdmlkaW5nIGEgImJpcmQncyBleWUgdmlldyIgb2YgeW91ciBuZXR3b3JrLCBhbmQgdGhleSBhcmUgdXNlZnVsIGZvciBjb21wYXJpbmcgZGlmZmVyZW50IG5ldHdvcmsgcmVwcmVzZW50YXRpb25zLiAKCiMjIyBBdmVyYWdlIFNob3J0ZXN0IFBhdGggTGVuZ3RoIAoKKipBdmVyYWdlIHNob3J0ZXN0IHBhdGggbGVuZ3RoKiogKEFTUEwpIHJlZmVycyB0byB0aGUgbWVhbiBvZiB0aGUgc2hvcnRlc3QgcG9zc2libGUgcGF0aCBiZXR3ZWVuIGFsbCBwb3NzaWJsZSBwYWlycyBvZiBub2RlcyBpbiB0aGUgbmV0d29yay4gKFRoaXMgbG9vc2VseSBjb3JyZXNwb25kcyB0byB0aGUgaWRlYSBvZiAic2l4IGRlZ3JlZXMgb2Ygc2VwYXJhdGlvbiIgaW4gc29jaWFsIG5ldHdvcmtzLikgIAoKIVtdKGh0dHBzOi8vZXh0ZXJuYWwtY29udGVudC5kdWNrZHVja2dvLmNvbS9pdS8/dT1odHRwcyUzQSUyRiUyRnRzZTIubW0uYmluZy5uZXQlMkZ0aCUzRmlkJTNET0lQLjdNNXBtRzR3NU5ucDYxMGkxajdyTFFIYUZ2JTI2cGlkJTNEQXBpJmY9MSkKCipFeGFtcGxlIGRlcGljdGluZyB0aGUgc2hvcnRlc3QgcGF0aCBiZXR3ZWVuIG5vZGVzIDI1IGFuZCAxNi4qCgpgYGB7cn0KIyB1bmRpcmVjdGVkLCB1bndlaWdodGVkIG5ldHdvcmsgCmF2ZXJhZ2UucGF0aC5sZW5ndGgoZ3JhcGggPSBwbmV0KSAKCiMgYW4gYWx0ZXJuYXRpdmUgZnVuY3Rpb24gLSBib3RoIGdpdmUgdGhlIHNhbWUgcmVzdWx0IAptZWFuX2Rpc3RhbmNlKGdyYXBoID0gcG5ldCkKCiMgZGlyZWN0ZWQsIHdlaWdodGVkIG5ldHdvcmsgCm1lYW5fZGlzdGFuY2UoZ3JhcGggPSBzbmV0LCB3ZWlnaHRzID0gTlVMTCwgZGlyZWN0ZWQgPSBUKSAjIGNvbnNpZGVyIHdlaWdodHMgYW5kIGRpcmVjdGlvbgptZWFuX2Rpc3RhbmNlKGdyYXBoID0gc25ldCwgd2VpZ2h0cyA9IE5VTEwsIGRpcmVjdGVkID0gRikgIyBpZ25vcmUgZGlyZWN0aW9uIAptZWFuX2Rpc3RhbmNlKGdyYXBoID0gc25ldCwgd2VpZ2h0cyA9IE5BLCBkaXJlY3RlZCA9IFQpICMgaWdub3JlIHdlaWdodHMgCmBgYAoKPHAgc3R5bGU9ImNvbG9yOmJsdWU7Ij4qUmVsZXZhbnQgZmluZGluZyBpbiBwc3ljaG9sb2d5OiBTaWV3ICgyMDE4KSBzaG93ZWQgdGhhdCBjb25jZXB0IG5ldHdvcmtzIChjb25zdHJ1Y3RlZCBmcm9tIGNvbmNlcHQgbWFwcyBnZW5lcmF0ZWQgYnkgc3R1ZGVudHMpIHdpdGggbGFyZ2VyIGF2ZXJhZ2Ugc2hvcnRlc3QgcGF0aCBsZW5ndGhzIHdlcmUgYXNzb2NpYXRlZCB3aXRoIGhpZ2hlciBxdWl6IHNjb3JlcywgYWZ0ZXIgY29udHJvbGxpbmcgZm9yIG5ldHdvcmsgc2l6ZS4qPC9wPgoKIyMjIEdsb2JhbCBDbHVzdGVyaW5nIENvZWZmaWNpZW50ICAKCioqR2xvYmFsIGNsdXN0ZXJpbmcgY29lZmZpY2llbnQqKiByZWZlcnMgdG8gdGhlIG51bWJlciBvZiBjbG9zZWQgdHJpYW5nbGVzIGluIHRoZSBuZXR3b3JrIHJlbGF0aXZlIHRvIHRoZSBudW1iZXIgb2YgcG9zc2libGUgdHJpYW5nbGVzLiBJdCBpcyBhIG1lYXN1cmUgb2Ygb3ZlcmFsbCBsZXZlbCBvZiAqbG9jYWwqIGNvbm5lY3Rpdml0eSBhbW9uZyBub2RlcyBpbiB0aGUgbmV0d29yay4gCgpBIHNpbXBsZSB3YXkgb2YgdGhpbmtpbmcgYWJvdXQgdGhpcyBjb25jZXB0IGlzIHRoYXQgaXQgaXMgbWVhc3VyaW5nIHRoZSBwcm9iYWJpbGl0eSB0aGF0IGVhY2ggcGFpciBvZiAiZnJpZW5kcyIgb2YgYSBnaXZlbiBub2RlIGFyZSBhbHNvIGZyaWVuZHMgd2l0aCBlYWNoIG90aGVyLgoKYGBge3J9CnRyYW5zaXRpdml0eShncmFwaCA9IHBuZXQsIHR5cGUgPSAnZ2xvYmFsJykKdHJhbnNpdGl2aXR5KGdyYXBoID0gc25ldCwgdHlwZSA9ICdnbG9iYWwnKQpgYGAKCiMjIyBTbWFsbCBXb3JsZCBJbmRleCAKClRoZSB0ZXJtICJzbWFsbCB3b3JsZCIgaGFzIGEgc3BlY2lmaWMgbWVhbmluZyBpbiBuZXR3b3JrIHNjaWVuY2UgYXMgY29tcGFyZWQgdG8gdGhlIGxheXBlcnNvbidzLiBBIG5ldHdvcmsgaXMgY29uc2lkZXJlZCB0byBoYXZlIHNtYWxsIHdvcmxkIGNoYXJhY3RlcmlzdGljcyBpZiAoaSkgaXRzIEFTUEwgaXMgKnNob3J0ZXIqIHRoYW4gdGhhdCBvZiBhIHJhbmRvbWx5IGdlbmVyYXRlZCBuZXR3b3JrIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIG5vZGVzIGFuZCBlZGdlcywgYW5kIChpaSkgaXRzIGdsb2JhbCBDIGlzICpsYXJnZXIqIHRoYW4gdGhhdCBvZiBhIHJhbmRvbWx5IGdlbmVyYXRlZCBuZXR3b3JrIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIG5vZGVzIGFuZCBlZGdlcy4gVGhlcmUgYXJlIHZhcmlvdXMgd2F5cyB0byBjb21wdXRlIGEgdmFsdWUgdGhhdCBxdWFudGlmaWVzIHRoZSAic21hbGwgd29ybGRuZXNzIiBvZiBhIG5ldHdvcmssIGFsdGhvdWdoIHdlIGRvIG5vdCBjb3ZlciB0aGVtIGhlcmUgKHNlZSBIdW1waHJpZXMgYW5kIEd1cm5leSwgMjAwOCwgZm9yIGFuIGV4YW1wbGUsIGFuZCBOZWFsLCAyMDE3LCBmb3IgYSBjb21wYXJpc29uIG9mIGRpZmZlcmVudCBtZXRob2RzKS4KClRoZSBtYWluIHRha2UgaG9tZSBtZXNzYWdlIGlzIHRoYXQgYSBzbWFsbCB3b3JsZCBuZXR3b3JrIGhhcyBoaWdoIGxldmVscyBvZiBsb2NhbCBjbHVzdGVyaW5nIChub2RlcyB3aG9zZSBuZWlnaGJvcnMgYXJlIGFsc28gbmVpZ2hib3JzIG9mIGVhY2ggb3RoZXIpLCBidXQgdGhlcmUgYWxzbyBleGlzdHMgYSBudW1iZXIgb2Ygc2hvcnRjdXRzIHRoYXQgZHJhc3RpY2FsbHkgcmVkdWNlcyB0aGUgb3ZlcmFsbCBkaXN0YW5jZXMvcGF0aCBsZW5ndGhzIGJldHdlZW4gbm9kZXMuIFNlZSBiZWxvdyBmb3IgYW4gaWxsdXN0cmF0aW9uIG9mIHRoaXMgaWRlYS4gCgohW10oaW1nL3NtYWxsLXdvcmxkLmdpZikKCiMjIyBOZXR3b3JrIERlbnNpdHkKCioqTmV0d29yayBkZW5zaXR5KiogcmVmZXJzIHRvIHRoZSByYXRpbyBvZiB0aGUgbnVtYmVyIG9mIChleGlzdGluZykgZWRnZXMgYW5kIHRoZSBudW1iZXIgb2YgcG9zc2libGUgZWRnZXMgYW1vbmcgbm9kZXMgaW4gdGhlIG5ldHdvcmsuIAoKIVtdKGltZy9kZW5zaXR5LnBuZykKCipTaW1wbGUgZXhhbXBsZSBvZiBuZXR3b3JrcyB3aXRoIGxvd2VyIGFuZCBoaWdoZXIgbmV0d29yayBkZW5zaXRpZXMuKgoKYGBge3J9CmdyYXBoLmRlbnNpdHkoZ3JhcGggPSBwbmV0KQpncmFwaC5kZW5zaXR5KGdyYXBoID0gc25ldCkKYGBgCgojIyMgTmV0d29yayBEaWFtZXRlciAKCioqTmV0d29yayBkaWFtZXRlcioqIHJlZmVycyB0byBsZW5ndGggb2YgdGhlIGxvbmdlc3Qgc2hvcnRlc3QgcGF0aCBiZXR3ZWVuIG5vZGVzIGluIHRoZSBuZXR3b3JrLiBJbnN0ZWFkIG9mIGdldHRpbmcgdGhlIG1lYW4gb2YgYWxsIHRoZSBzaG9ydGVzdCBwYXRocyBhcyB5b3UgZGlkIGluIEFTUEwsIHdoYXQgaXMgdGhlICptYXhpbXVtKiBsZW5ndGggb2YgdGhvc2Ugc2hvcnQgcGF0aHM/IAoKIVtdKGltZy9kaWFtZXRlci5wbmcpCgoqU2ltcGxlIGV4YW1wbGUgb2YgbmV0d29ya3Mgd2l0aCBoaWdoZXIgYW5kIGxvd2VyIG5ldHdvcmsgZGlhbWV0ZXJzKgoKYGBge3J9CiMgdW5kaXJlY3RlZCwgdW53ZWlnaHRlZCBncmFwaCAKZGlhbWV0ZXIoZ3JhcGggPSBwbmV0KQoKIyBkaXJlY3RlZCwgd2VpZ2h0ZWQgZ3JhcGggCmRpYW1ldGVyKGdyYXBoID0gc25ldCwgZGlyZWN0ZWQgPSBULCB3ZWlnaHRzID0gTlVMTCkgIyBjb25zaWRlciB3ZWlnaHRzIGFuZCBkaXJlY3Rpb24KZGlhbWV0ZXIoZ3JhcGggPSBzbmV0LCBkaXJlY3RlZCA9IEYsIHdlaWdodHMgPSBOVUxMKSAjIGlnbm9yZSBkaXJlY3Rpb24gCmRpYW1ldGVyKGdyYXBoID0gc25ldCwgZGlyZWN0ZWQgPSBULCB3ZWlnaHRzID0gTkEpICMgaWdub3JlIHdlaWdodHMgCmBgYAoKIyBBZGRpdGlvbmFsIFJlc291cmNlcyAKCk9nbnlhbm92YSwgSy4gKDIwMjEpIE5ldHdvcmsgdmlzdWFsaXphdGlvbiB3aXRoIFIuIFJldHJpZXZlZCBmcm9tIHd3dy5rYXRldG8ubmV0L25ldHdvcmstdmlzdWFsaXphdGlvbi4gaHR0cHM6Ly9rYXRldG8ubmV0L25ldHdvcmstdmlzdWFsaXphdGlvbgoKVGhlIG9mZmljaWFsIGBpZ3JhcGhgIG1hbnVhbCAodi4xLjMuNCkuIGh0dHBzOi8vaWdyYXBoLm9yZy9yL2RvYy8gCgpHZXBoaTogQSBtdWx0aS1wbGF0Zm9ybSwgZnJlZSB0byBkb3dubG9hZCBHVUkgYXBwIGZvciBuZXR3b3JrIGFuYWx5c2lzIGFuZCB2aXN1YWxpemF0aW9uLiBodHRwczovL2dlcGhpLm9yZy8KCiMgUmVmZXJlbmNlcyAKCkJhcnJhdCwgQS4sIEJhcnRow6lsZW15LCBNLiwgUGFzdG9yLVNhdG9ycmFzLCBSLiwgJiBWZXNwaWduYW5pLCBBLiAoMjAwNCkuIFRoZSBhcmNoaXRlY3R1cmUgb2YgY29tcGxleCB3ZWlnaHRlZCBuZXR3b3Jrcy4gUHJvY2VlZGluZ3Mgb2YgdGhlIE5hdGlvbmFsIEFjYWRlbXkgb2YgU2NpZW5jZXMsIDEwMSgxMSksIDM3NDfigJMzNzUyLiBodHRwczovL2RvaS5vcmcvMTAuMTA3My9wbmFzLjA0MDAwODcxMDEKCkJsb25kZWwsIFYuIEQuLCBHdWlsbGF1bWUsIEouIEwuLCBMYW1iaW90dGUsIFIuLCAmIExlZmVidnJlLCBFLiAoMjAwOCkuIEZhc3QgdW5mb2xkaW5nIG9mIGNvbW11bml0aWVzIGluIGxhcmdlIG5ldHdvcmtzLiBKb3VybmFsIG9mIFN0YXRpc3RpY2FsIE1lY2hhbmljczogVGhlb3J5IGFuZCBFeHBlcmltZW50LCAyMDA4KDEwKSwgUDEwMDA4LgoKQ2hhbiwgSy4gWS4sICYgVml0ZXZpdGNoLCBNLiBTLiAoMjAwOSkuIFRoZSBpbmZsdWVuY2Ugb2YgdGhlIHBob25vbG9naWNhbCBuZWlnaGJvcmhvb2QgY2x1c3RlcmluZyBjb2VmZmljaWVudCBvbiBzcG9rZW4gd29yZCByZWNvZ25pdGlvbi4gSm91cm5hbCBvZiBFeHBlcmltZW50YWwgUHN5Y2hvbG9neTogSHVtYW4gUGVyY2VwdGlvbiBhbmQgUGVyZm9ybWFuY2UsIDM1KDYpLCAxOTM04oCTMTk0OS4gaHR0cHM6Ly9kb2kub3JnLzEwLjEwMzcvYTAwMTY5MDIKCkRlIERleW5lLCBTLiwgTmF2YXJybywgRC4gSi4sIFBlcmZvcnMsIEEuLCBCcnlzYmFlcnQsIE0uLCAmIFN0b3JtcywgRy4gKDIwMTkpLiBUaGUg4oCcU21hbGwgV29ybGQgb2YgV29yZHPigJ0gRW5nbGlzaCB3b3JkIGFzc29jaWF0aW9uIG5vcm1zIGZvciBvdmVyIDEyLDAwMCBjdWUgd29yZHMuIEJlaGF2aW9yIFJlc2VhcmNoIE1ldGhvZHMsIDUxLCA5ODfigJMxMDA2LgoKRm9ydHVuYXRvLCBTLiAoMjAxMCkuIENvbW11bml0eSBkZXRlY3Rpb24gaW4gZ3JhcGhzLiBQaHlzaWNzIFJlcG9ydHMsIDQ4NigzLTUpLCA3NS0xNzQuCgpIdW1waHJpZXMsIE0uIEQuLCAmIEd1cm5leSwgSy4gKDIwMDgpLiBOZXR3b3JrIOKAmHNtYWxsLXdvcmxkLW5lc3PigJk6IEEgcXVhbnRpdGF0aXZlIG1ldGhvZCBmb3IgZGV0ZXJtaW5pbmcgY2Fub25pY2FsIG5ldHdvcmsgZXF1aXZhbGVuY2UuIFBsb1MgT25lLCAzKDQpLgoKR3JpZmZpdGhzLCBULiBMLiwgU3RleXZlcnMsIE0uLCAmIEZpcmwsIEEuICgyMDA3KS4gR29vZ2xlIGFuZCB0aGUgTWluZDogUHJlZGljdGluZyBGbHVlbmN5IFdpdGggUGFnZVJhbmsuIFBzeWNob2xvZ2ljYWwgU2NpZW5jZSwgMTgoMTIpLCAxMDY54oCTMTA3Ni4gaHR0cHM6Ly9kb2kub3JnLzEwLjExMTEvai4xNDY3LTkyODAuMjAwNy4wMjAyNy54CgpMdWNlLCBQLiBBLiwgJiBQaXNvbmksIEQuIEIuICgxOTk4KS4gUmVjb2duaXppbmcgc3Bva2VuIHdvcmRzOiBUaGUgTmVpZ2hib3Job29kIEFjdGl2YXRpb24gTW9kZWwuIEVhciBhbmQgSGVhcmluZywgMTkoMSksIDHigJMzNi4KCk5lYWwsIFouIFAuICgyMDE3KS4gSG93IHNtYWxsIGlzIGl0PyBDb21wYXJpbmcgaW5kaWNlcyBvZiBzbWFsbCB3b3JsZGxpbmVzcy4gTmV0d29yayBTY2llbmNlLCA1KDEpLCAzMOKAkzQ0LiBodHRwczovL2RvaS5vcmcvMTAuMTAxNy9ud3MuMjAxNy41CgpOZXdtYW4sIE0uIEUuICgyMDA2KS4gTW9kdWxhcml0eSBhbmQgY29tbXVuaXR5IHN0cnVjdHVyZSBpbiBuZXR3b3Jrcy4gUHJvY2VlZGluZ3Mgb2YgdGhlIE5hdGlvbmFsIEFjYWRlbXkgb2YgU2NpZW5jZXMsIDEwMygyMyksIDg1NzctODU4Mi4gICAKClNpZXcsIEMuIFMuIFEuICgyMDEzKS4gQ29tbXVuaXR5IHN0cnVjdHVyZSBpbiB0aGUgcGhvbm9sb2dpY2FsIG5ldHdvcmsuIEZyb250aWVycyBpbiBQc3ljaG9sb2d5LCA0LCA1NTMuCgpTaWV3LCBDLiBTLiBRLiAoMjAxOCkuIFRoZSBvcnRob2dyYXBoaWMgc2ltaWxhcml0eSBzdHJ1Y3R1cmUgb2YgRW5nbGlzaCB3b3JkczogSW5zaWdodHMgZnJvbSBuZXR3b3JrIHNjaWVuY2UuIEFwcGxpZWQgTmV0d29yayBTY2llbmNlLCAzKDEpLCAxMy4KClNpZXcsIEMuIFMuIFEuICgyMDE4KS4gVXNpbmcgbmV0d29yayBzY2llbmNlIHRvIGFuYWx5emUgY29uY2VwdCBtYXBzIG9mIHBzeWNob2xvZ3kgdW5kZXJncmFkdWF0ZXMuIEFwcGxpZWQgQ29nbml0aXZlIFBzeWNob2xvZ3kuCgpWaXRldml0Y2gsIE0uIFMuICgyMDA4KS4gV2hhdCBjYW4gZ3JhcGggdGhlb3J5IHRlbGwgdXMgYWJvdXQgd29yZCBsZWFybmluZyBhbmQgbGV4aWNhbCByZXRyaWV2YWw/IEpvdXJuYWwgb2YgU3BlZWNoLCBMYW5ndWFnZSwgYW5kIEhlYXJpbmcgUmVzZWFyY2gsIDUxKDIpLCA0MDjigJM0MjIuIGh0dHBzOi8vZG9pLm9yZy8xMC4xMDQ0LzEwOTItNDM4OCgyMDA4LzAzMCkK</div>
<p>Copyright &copy; 2023 CSQ Siew. All rights reserved.</p>

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("CompCog23.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
